#pragma once
/*
	1. SetTimerByEvent의 실햄흐름은 다른 흐름이라고 봐야 함
	- 세팅된 시간만큼 바인딩 된 이벤트의 흐름을 실햄 함
	- 타이머 설정을 해주었으면 필요하지 않을 때 꺼야하는데
	- pause하는 방법이 있고 timer를 비웠다가 다시 세팅하는 식의 방법이 있음
	- 걸어준 이벤트에 함수를 거는 방법이 있는데 이벤트 생성 노드를 만들어서 함수를 걸어주었음
	- 근데 이벤트 디스패처가 함수를 커스텀 이벤트로 만드는 것이냐고 했을 땐 아닌 것이
	- 이벤트 디스패처의 본질은 함수 포인터인 것이고 단지 걸어준 함수를 이벤트로서 사용할 수 있던 것

	- pause, unpause는 unpause 당시 시간이 남아있기 때문에 부정확할 수 있음
	- 그런 오차가 허용 안되는 상황이면 타이머를 비우는 방식을 채택해야 함
	
	2. 위에서 사용했던 이벤트 생성은 싱글캐스트 델리게이트 인것 같음
	- 이유는 변수로 만들 수 있는 이벤트 디스패처는 기본값이 멀티캐스트 델리게이트이며 편집이 불가능한데
	- 이걸 만들어서 SetTimerByEvent에 걸어주고 싶었는데 실패했음
	- 그리고 이벤트 생성 노드도 핀추가라던가 더 걸어줄 함수를 추가하는 핀이 없었음

	- 이벤트 디스패처에 여러 이벤트를 걸었다면 그 디스패처를 호출해서 실행흐름이 있는 핀으로서 연겨해주면 되는데
	- 이게 SetTimer노드의 이벤트에 바인딩 되려면 디스패처를 커스텀이벤트로서 다시 만들어서 거기서 호출 노드를 흐름으로 연결해주면 됨

	- 이벤트 디스패처에는 input인자들이 같고 output은 없어야 함
	- 멀티캐스트에서는 기본적으로 반환값을 활용을 못하는데 블프에서는 반환값이 있으면 그 자체로도 멀티캐스트 델리게이트에 걸어줄 수 없었고
	- C++에서는 반환값이 있어도 걸어줄 순 있으나 반환값의 활용은 힘든 것으로 보임

	3. 멀티캐스트 델리게이트는 옵저버 패턴에 활용하기에 좋음
	- 업적 시스템같은
	- 기본적으로는 인터페이스가 더 강력하기 때문에 인터페이스를 적극 활용하는 것이 좋음(커플링 면에서도 인터페이스가 약한 커플링)

	4. EndOverlap에서 OverlappedActors배열을 비워주는 것과 별개로 스킬이 끝나는 시점에서도 비워줘야 함
	- 버그가 발생할 수 있음
	- 아마 겹쳐있는 시점에서 EndOverlap이 호출되지 않고 스킬이 꺼지면 그럴 수 있다는 것 같음

	5. overlappedactor가 배열인 이유는 결국 특정 원소를 꺼내야 처리할 수 있는 내용이 있기 때문
	- overlap이 끝나면 특정 액터를 배열에서 비워주는 식의 작업이 이에 해당
	- set이였다면 결국 배열로 바꿔서 처리해야 하기 때문에 2번 일하는 꼴

	6. 블프의 배열은 읽기 전용으로 걸어도 값이 변경 가능함
	- 이런 빈틈이 있는 이유는 ADD, REMOVE같은 함수가 Library에서 불러 쓰는 것이기 때문
	- Set같은 경우는 막을 수 있음(다른 배열을 통째로 덮어 쓰는 경우)

	7. RotateVectorAroundAxis가 있는데 우리 수업은 고정 값 정면 벡터에 대해 angle값만 변경시켜주어서 스킬의 location을 정해주는 방식
	- 아마 중요한 점은 angle이 변하는 값이고 벡터는 고정값이어야 함
	- 축은 z축을 기준으로 주었는데 getactorforwardvector라던가 다양한 vector를 넘겨주어서 다양한 표현이 가능

	8. 결국 파이어스톰이 캐릭터 주위를 돌수 있는 것은
	- 월드상의 원점을 기준으로 어떤 방향을 가질 지 벡터를 정해놓고 그 벡터에 얼마만큼 멀어질지 상수값을 곱해서
	- 내 캐릭터의 위치에 그 벡터를 틱마다 더해주어야 가능

	9. 새로운 스킬 파이어볼을 만들기 위해 스킬이 activate된 시점에 몸 주변에 불타는 오라를 켜줬는데 꺼질 때 반응이 늦어보임
	- 파티클 자체에 꺼질 때 딜레이를 얼마나 줄지에 대한 옵션이 있긴 한데 잘 적용이 안된다고 함
	- 바로 꺼지길 원한다면 visible을 건드리면 된다고 함
	- 이거 관련해서 파티클의 원본에 가서 특정 이미터에 적용된 lifetime에서 값을 수정해주면 되긴 함

	- 추가로 파티클 관련해서 따로 만져봤는데 캐스케이드(파티클 편집기) 내에 커브에디터에 특정 이미터에 소속된 특정 이미터를 올려주면 값 그래프로서 편집이 가능함
	- 이미터에 걸려있는 머티리얼에 대해 dynamic으로 바꾸고 값을 바꿔주는 식으로 해봤는데 이미터가 그 머티리얼에 색을 덧씌운다던가 하는 방식으로
	작동하기에 적용이 안 되었었음
	- 현재로선 파티클을 내 입맛대로 다루려면 케스케이드에서 내가 직접 편집하는 수밖에 없는 듯
	- 개인적으로는 파티클의 전체 visibility를 꺼버리기 보단 파티클을 직접 편집하는 게 연출 상 더 좋아보이는데
	- 큰 덩어리는 빠르게 꺼주고 잔상은 남기는 식으로 편집하면 좋을 듯

	10. ABP에서 본마다 레이어로 블렌딩 노드에서 MeshSpaceRotationBlending 옵션이 있었는데 이걸 체크해주어야 Wizard_Attack 몽타주가 제대로 동작
	- 로컬 스페이스는 spine_01을 기준으로 하체에 대해서 원래 애니메이션이 회전이 없기 때문에 회전을 안 시킨 듯
	- 하지만 wizard_idle포즈와 wizard_attack포즈가 각각 개별로 동작했을 때 이걸 블렌딩 하면 실제로는 attack시 하체는 그대로고 상체가 돌아야 함
	- 메시 스페이스에서의 회전을 적용시켜줘서 하체와 상체가 기존의 애니메이션과는 다르게 돌릴 수 있었음

	11. 캐릭터에 적용된 스켈레탈 메시는 -90도 돌리고 z위치를 -90 내려서 적용해주었는데
	- 이렇게 되면 기존의 스켈레탈 메시랑 비교해서 정면 축이 바뀐 것이고 이것이 본마다 레이어로 블렌딩 노드에서 문제가 생기게 된 이유임
	
	12. 로컬 스페이스에서 블렌딩을 하게 되면 그 공간에서 attack 애니메이션은 하체에 연결 되어서 하체의 rotation에 영향을 받은 애니메이션인거고
	메시 스페이스는 하체에 영향을 받았더라도 최종적으로 하체가 영향을 준 상체를 블렌딩하겠다는 뜻

	13. 이렇게까지 하고 나면 상체가 너무 도는 문제가 있었는데 상체 부분에 블렌딩 된 애니메이션에 대해 뼈마다 얼마나 적용할지 정해주는 BlendDepth옵션이 있었음
	- 설정한 뼈를 기준으로 BlendDepth가 4라면 설정한 뼈는 1/4의 블렌드를 그 뼈 바로 위의 자식은 1/3, 그 위는 1/2, 1/1, 1/1, 1/1...되는 옵션임
	- 그래서 Depth가 높아지면 설정한 뼈 근처에서는 블렌딩 된 애니메이션이 적게 나오기 때문에 허리가 덜 돌아가 보이는 것

	14. 지금 설정한 뼈가 0번의 0번 인덱스인데 0번의 1번 0번의 2번 이런 식으로 블렌딩하기 위해 들어오는 애니메이션에 옵션을 더 달아 줄 수 있고
	- 만약에 노드 자체에 핀을 추가해서 1번 애니메이션 2번 애니메이션을 추가로 블렌딩 할떄는 1번의 0번, 1번의 1번, 2번의 0번, 2번의 1번 이런 식으로
	몇 번째 애니메이션의 뼈에 얼마만큼의 뎁스를 줄지를 각각 정해 줄 수 있음
	- 우리가 한 건 0번의 0번, 0번의 1번, 0번의 2번 식으로 0번 애니메이션에 대해서만 옵션을 정해 준 것

	15. spine_01에 blenddepth를 3을 준거랑 pelvis에는 4주고 thigh_l, thigh_r에 -1을 주는 것에 차이는
	- pelvis에 1/4만큼의 블렌딩될 애니메이션이 적용되는 것
	- -1은 해당 본 밑으로 적용 안 시켜줌
	- 0은 해당 본에만 적용
*/