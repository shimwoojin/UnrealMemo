#pragma once
/*
1. 1교시는 블프 과제 조사한 읽어본 후 인터페이스에 대한 설명
 - 인터페이스는 성격이 다른 두 클래스간에 공통된 기능으로 묶어줄 수 있었고
 - C++의 관점에선 헤더를 줄인다거나 하나의 인터페이스 포인터로 하위 클래스들을 묶어서 기능에 대한 구현이 간편해졌음
 - 인터페이스는 메모리에 특정할 수 있는 공간을 가지지 않는다는 규칙만 지켜주면 기존 인터페이스의 규칙에서 벗어난 변종들이 많음

2. 구현한 인터페이스의 함수에 대해서 같은 함수지만 인터페이스 콜과 함수 호출의 차이는 타깃이 다름
 - 타깃이 다르다는 건 인터페이스로서 호출할 지 클래스 자체로 호출할 지 정도의 차이, 내부와 외부 사용 정도의 차이도 맞는 거 같음

3. 인터페이스 콜은 실패하면 조용히 실패하는 점에서 장점이 될 수 있음

4. BP_Weapon을 만들었는데 SkeletalMesh를 Root로 올려줌, StaticMesh가 아닌 SkeletalMesh인 이유는 무기가 애니메이션을 가지는 경우도 있고
무기에서 파티클의 위치를 정할 때도 용이하기 때문

5. BP_Weapon에서 overlap이벤트 발생 시 ApplyDamage함수에 이어놨음
 - ApplyDamage에서 BaseDamage는 특정할 수 없기에 변수로 승격시켜줬고
 - EventInstigator는 누가 이 데미지를 유발했냐 인데 이게 Player를 핀으로 받을수도 있고 Controller를 핀으로 받을수도 있는데 이 경우는 controller였음
 - DamageCauser : Self

6. BP_Character에서 AnyDamage이벤트로 Damage주는 이벤트에 대한 처리를 해주었는데 BP_Character였던 이유는 Character를 상속해주는 클래스에서
데미지 처리를 하기 위해서 인듯 ?

7. BP_Weapon에서 만든 Damage변수를 자식인 BP_Sword에서 기본값을 10 주었는데 데미지가 0인 경우 이벤트가 발생을 안함

8. 칼을 장착해주기위해 SK_Mannequin의 스켈레톤 트리를 편집해주었는데 이때 무기를 껴야할 오른손인 hand_r에 소켓을 만들어서 프리뷰 에셋 보기를 통해서
칼의 위치를 잘 잡아줌
 - 프리뷰 에셋 보기는 우리가 만든 BP_Sword의 클래스가 아니라 그저 에셋을 보기 때문에 아까 Mesh가 root였던 이유가 그 이유임
 - 기껏 위치 잡아놨는데 mesh가 다른 root에 대해 상대적인 위치라면 프리뷰 한것과 다른 위치에 스폰됨
*/