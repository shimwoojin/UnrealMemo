#pragma once
/*
1. 칼 꺼내는 동작을 구현한 그래프에서 문제점을 찾아보는 것이 과제였었는데 그 중 문제로 제기됐던 것 중 하나로 칼을 꺼낸 후 구르고 나면 칼을 꺼내는 모션이 다시
동작하는 것이였음
 - 이것의 이유는 몽타주가 재생하고 나면 스테이트 머신의 entry부터 다시 진행하게 되기 때문인데
 - 간단하게 해결할 수 있는 방법은 몽타주의 옵션중에 Always update source pose 옵션을 체크해주면 해결되었음
 - 저 옵션의 위치는 anim graph 에서 슬롯에 왼클릭 후 디테일 탭에서 설정 가능

2. 검을 뽑으면서 움직여지는 것도 문제 중에 하나였는데 간단한 해결법은 root motion을 켜주는 것이었음
 - Draw1, Draw2의 enable root motion을 켜주고 ABP_Character의 클래스 디폴트에서 root motion 관련 옵션중에 몽타주뿐만 아니라 전부에 적용할 수 있는데
이 옵션을 켜게 되면 해결은 가능하나 이 방법은 아님

3. 블프에서 디버깅하는 방법에 대해서도 나왔는데
 - 블프 디버깅은 인스턴스에 대한 디버깅으로 플레이 중에 특정 인스턴스에 대한 중단점을 걸어서 확인해 볼 수 있음

4. 노티파이 관련해서도 스켈레톤에 노티파이 추가를 하게 되면 특정 본에만 적용되는 노티파이가 되는 것이기 때문에 확장성이 떨어짐 (문제 1)
 - 여러 스켈레톤에 대해 같은 동작을 정의하고 싶으면 이 방법은 지양해야 함

5. BP_Character에 형변환해서 사용하는 이런 방법은 확장성이 떨어짐, 유지보수 불리 (문제 2)

6. 문자열에 의존하는 것은 지양해야 하는데 문자열에 대해 변수로서 관리하는 방법을 항상 고민해 봐야 함
 - socket에 대해 이걸 적용해본다면 GetOwningComponent - GetAllSocketNames 를 얻어와서 처리하는 방법이 가능하긴 하나
 - socket의 경우 그냥 조심해서 사용해야 하는 것 같음

7. 형변환은 언리얼 기본 제공 클래스에 대해서만 꼭 필요할 때 하는 것을 추천하고 키입력 이벤트는 테스트용으로만 사용해보고 앵간하면 controller 쪽에서 처리해야 함

8. 결국 언리얼 포폴이란 것은 1) 블프로 한다면 나 블프 다룰 줄 안다는 것을 알려주는 것이고 2) 구조설계를 잘했다를 어필하면 좋을 수 있음

9. AnimGraph에서 들어오거나 나갈 때 블레딩될때의 이벤트를 각각 이름 지어주어서 다른 클래스의 이벤트그래프에서 사용할 수 있었고
이것은 트랜지션에 대해서도 마찬가지(트랜지션 : 애니메이션이 변하는 조건 정의해준 곳)
 - 몽타주가 아닌 애니메이션 시퀀스 혹은 상태머신에 들어와서 애니메이션 시퀀스에 대해서 이 옵션 조절 가능
 - 상태머신에서 트랜지션 룰에 대해서도 마찬가지로 이벤트 생성 가능
 - 애니메이션 간에 블렌딩에 관해서도 옵션이 있음, 시간 몇초 부터 섞을지 ?

10. 블프 그래프 정리하는 것에 대해선 전체 드래그 한 다음 q 누르면 자동으로 정리 되고
 - shift + wsad 로 정렬하는 것 정도 있음

11. 에디터 개인설정에서 새 창 뜨는 것들에 대해 main window에 붙이는 것에 대한 옵션이 있었고
 - 일반 - 외형 - 에셋 에디터 실행 위치 에서 조절 가능
 - 에디터 개인설정에서 블프 그래프 움직이는 모션 스무스하게 바꿀 수 있고 (그리드 크기?)
 - 뒤 모눈 없애는 설정도 있었음

12. 기존 방식은 월드에서 위치 상관없이 스폰한 후 bone_spine_03에 다시 붙여주는 방식이였다면
 - 무기가 캐릭터의 어디 붙어야 할지에 대한 정보를 가지고 이 정보를 만들자마자 해주는 처리를 한다한 거 같음

13. 위에서 언급한 특정 클래스로 형변환 하는 것은 문제가 되기 때문에 WeaponA, WeaponB를 드는 동작에 대해 액션매핑을 해주었고
그 동작에 대해 인터페이스도 만들어주었음
 - 무기드는 동작에 대해 액션매핑한 이벤트를 호출할 때 단지 인터페이스로 정의한 함수를 부르기만 하면 됨
 - 인터페이스를 상속받은 클래스에서 다르게 처리해야 할 동작이 있다면 거기서 처리

14. 입력에 대해서(아마도 프로젝트 세팅에서 매핑해놓은 키 입력 이벤트에 대한 것만 해당하는 듯) 상위의 존재가 입력을 소모해버리면 밑에서는 입력을 못 받게 되는 구조를 띄는데 그 순서는
 - 1) input enabled actor 2) controller 3) level blue print 4) pawn 순인데
 - 위에서 입력 이벤트를 처리했어도 입력을 소모시키지 않는 옵션이 있는데 어딨냐면
 - 축매핑을 사용하겠다고 이벤트에 배치한 곳에서 좌클릭 후 디테일 탭에서 확인 가능, consume input 옵션

15. 입력에 대해서 위에서 설명한 4개 구조에 대해서 하위로 아예 input을 안 줘버리겠다는 식으로 쓰고 싶으면 예를 들어 player controller 밑으로 못 쓰게 하려면
 - controller쪽의 클래스 디폴트에 입력 관련 옵션에 block input 옵션이 있음
 - 최종은 이렇게 쓰는 것이 좋아보이고 작업하는 과정에선 테스트 input을 받아 봐야 하기 때문에 옵션 풀어줌

16. BP_Character에서 인터페이스에 대해 상속 받고 WeaponA, WeaponB에 대해서 구현해주는데,,
 - 이벤트에선 지역변수 선언이 불가능한데 이것에 대해서 꼼수? 처럼 쓰는 방법이 있음
 - 지역변수 관련해서 make float, make int 등과 설명해준다 했음

17. 16번에서 말한 꼼수는 Uobject에 대해서 매크로 라이브러리를 하나 새로 만들고 매크로를 하나 새로 만들어서 출력 핀을 와일드 카드로 주는 방법이였음
 - 아마 와일드카드가 어떤 변수로든 변환해서 사용가능하고 이걸 이벤트의 로컬처럼 쓰는 것 같음

18. 매크로를 만들 때 계층을 설정해주는 이유는 character의 고유한 함수인 jump를 예를 들면 이 함수가 uobject 밑에서 매크로로 되어 있으면 문제가 생긴다는 것임
 - character가 아닌 데서 치환되는 식으로 그 함수가 들어가면 문제
*/