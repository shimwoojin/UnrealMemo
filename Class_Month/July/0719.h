#pragma once
/*
	1. 캐릭터 기준 배꼽, 왼손, 오른손, 발, 머리 쪽에 애로우 컴포넌트 달아줌
	- 장애물에 대한 조사를 위해서 달아준 보조 컴포넌트임(위치와 방향 제공)
	- 모든 애로우에서 라인 트레이스를 해서 장애물을 감지해 볼 수도 있지만 쓸데없는 계산은 줄이기 위해 배꼽 쪽 라인트레이스가 감지되면 추가로 감지되는 방식으로 구성할 예정

	2. SceneComponent::GetForwardVector()로 트랜스폼을 가지는 컴포넌트들은 정면벡터를 얻어올 수 있음
	- 하지만 Rotation에서 정면 벡터를 뽑아오고 싶은 경우 쿼터니언으로 변환 후 정면벡터를 뽑아올 수 있음

	3. TMap<>의 경우 key값이 없는 상태에서 = 연산자로 value값을 넣으려고 한다면 오류남(구현 된 내용이 없는 듯)
	- 헷갈릴 수 있는 부분은 C++ 문법은 위와 같은 내용을 지원함

	ex. std::map<char, int> MyMap;
	MyMap['c'] = 1;

	같은 문법이 원래는 가능하다는 것임 -> TMap<>은 안 됨(엔진 튜닝 ㄱ ?)

	- TMap::Add(AnyType key) 오버로딩 버전 중에 key만 넘겨서 기본 값 잡을 수도 있긴 함, 위 안되는 내용을 보완할려고 만들었나,,
	- = 연산자로 할당하고 싶으면 Add의 key만 받는 버전으로 기본 값 잡아놓고 해주면 됨

	4. 지역 내에서 typedef을 사용하여 그 지역 내에서만 타입에 별명 지어서 사용 가능
	- typedef UStaticMeshComponent MeshType;
	- 어느 경우에 유용하냐면 1) 위처럼 변수 이름이 길다거나 2) int32 -> int64처럼 바뀔 수도 있는 경우나 3) 타입 자체가 별명을 가져 표현하고 싶은 경우

	- 지역을 벗어나면 typedef은 없던 일로 됨(흔히 알고 있던 지역의 개념이 먹힌다고 보면 될 듯)

	- 추가로 using MeshType = UStaticMeshComponent; 처럼 같은 표현을 할 수도 있지만 언리얼은 위 문법이 작동안하는 경우가 있다고 함

	5. TWeakObjectPtr의 -> 는 오버로딩 되어 있음
	- 무슨 말이냐 하면 weak pointer는 Cpp에서 사용하기 전에 .get()을 하여야 사용할 수 있었는데
	- -> 를 오버로딩함으로서 return ~~.Get()을 해주게 되는데
	- ->와 같은 연산자들은 오버로딩 시 원래의 기능을 잃지 않음(구조체나 클래스 포인터의 멤버에 접근하는 기능 자체는 오버로딩을 해도 사라지지 않는다는 뜻)
	- 구조체나 클래스의 멤버에 접근하는 연산자 . 는 오버로딩하면 기능을 잃는 건지 오버로딩이 안 되는 건지 ->랑 다르다고 함

	- 추가로 new 도 오버로딩이 가능한데 new는 메모리 상 공간을 잡아주고 클래스의 생성자를 불러주는 역할까지 여러가지를 하게 되는데
	- 우리가 new를 오버로딩을 하게 되면 원래의 기능 중에 클래스의 생성자를 불러준다거나 하는 기능은 안 잃는다는 관점에서 -> 를 오버로딩하는 것과 비슷하다고 함

	6. UStaticMeshComponent::GetLocalBounds(FVector& Min, FVector& Max);
	- 스태틱 메쉬를 직육면체로 가뒀다고 가정했을 때 모서리 점을 담아올 수 있는 함수 -> 매개변수를 작성 시 const가 붙지 않음으로서 수정 반환 할 것임을 알 수 있었음

	7. AActor::GetActorScale()과 AActor::GetActorScale3D()는 내부 구현이 같음
	- 삼항 연산자 vs if문 으로 내부 구성이 다를 뿐이지 return 값 자체는 같음

	8. UKismetMathLibrary::MakeRotFromX(-Result.Normal).Yaw;
	- 라인 트레이스로 얻은 메쉬 표면에 수직인 (메쉬로 향하는 방향의 수직) 방향을 yaw로서 float값(-180 ~ 180)으로 받게 됨
*/