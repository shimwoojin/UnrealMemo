#pragma once
/*
	1. 블프 -> C++ 프로젝트 전환은 블프 프로젝트에서 그냥 C++ 클래스 만들면 됨

	2. .Net Frame Work 4.6.1 이상 설치해야 함
	- C++로 열기 위해선 필요한가 봄

	3. VS2023 버전은 지원 안 되는 것 같음

	4. C++ 프로젝트 경로엔 한글 안 들어가게 유의

	5. Unreal C++ 프로젝트는 실제 경로와 프로젝트 상 보이는 경로가 일치하지 않음
	- 폴더와 필터의 차이임
	- 엔진 소스들은 설치 경로 상 이곳 저곳 퍼져있기 때문에 편의를 위해 이렇게 제공하는 듯
	- 헤더와 cpp파일들은 좌측 하단에 파란 표시가 나는데 <weak ptr> 정도로 생각하면 될 듯 -> 변경사항은 다 반영이 되지만 삭제 시 프로젝트에서의 삭제일 뿐 실제 경로에서 삭제하는 것이 아님

	6. C++ 프로젝트는 Content, Config, Source, UProject가 필수 요소
	- .vs : vs의 인텔리전스에 대한 데이터베이스나 vs의 세팅 정보를 저장하는데 시간이 지나면 용량이 굉장히 커질 수 있으나 편의를 위해 프로젝트 진행 중엔 냅두는 것이 좋을 듯
	- Binaries : 사용자의 C++을 빌드한 목적 파일, .dll은 이곳에 있음(C++ 빌드 결과물)
	- Intermediate : 언리얼 헤더 툴에 의해 생성 된 generate.h 파일이 여기 있음, 프로젝트 기본 생성시에도 1GB정도 차지하는데 어떤 것이 있는지는 더 알아봐야 함
	솔루션 관련 파일들도 Intermediate에 생성 됨(.sln과 별도로 관리)
	- Saved : 차차 알아보도록
	- Source : 헤더, Cpp -> 우리의 메인 폴더

	- sln : vs의 프로젝트를 지워도 재생성가능 -> 폴더 경로의 .uproject에 우클릭 후 generate ... 누르면 새로 솔루션 만들어 줌

	7. 위에서 필터에서 지워봤자 실제 경로에서 지우는 것이 아닌 프로젝트에서 제외하는 거라 했는데 반대로 추가하려면
	- 위치 시킬 경로에 파일을 위치하고 필터에 드래그 해오면 됨
	- 혹은 프로젝트에 추가하는 단축키 활용

	8. 엔진에서 제공하는 헤더 혹은 cpp의 실제 경로가 궁금하면 그 파일에 대해 우클릭 후 경로로 이동 가능함

	9. <프로젝트명.h>가 어떤 용도인지는 알아봐야 함

	10. <프로젝트명.build.cs>는 모듈을 string으로서 추가하는 C# 코드
	- 기본 제공 모듈은 Core, CoreUObject, Engine, InputCore인데 Engine에서 대부분의 Conponents들을 포함시켜주는 것 같음(엔진 API 참고함) 
	- 블프에선 그냥 쓰던 AI 기능을 쓰고 싶으면 "AIModule"을 이 폴더에 문자열로 추가해줘야 함

	- Slate UI는 주석이 쳐져있는데 UI 프로그래밍하는 기능임 (html 같은 ?)

	11. 언리얼 C++마법사로 새로운 클래스(이번엔 액터였음)를 만들게 되면 VS상에선 외부에서 변경했다고 문구가 뜸
	- 변경사항을 반영해줘야 함

	12. 새 클래스의 맨 위 주석은 <프로젝트 세팅 - 법률 - 저작권 고지>에서 문구를 바꿀 수 있음

	13. 접두어를 간단히 알아보면
	- U : UObject
	- A : AActor
	- T : Template
	- F : C++

	14. C++에서 지원하지 않거나 엔진에 필요한 기능은 대부분 매크로로서 지원함
	- UCLASS(), GENERATED_BODY(), 프로젝트명_API 등

	15. 프로젝트명_API를 알아보면 -> #define 프로젝트명_API DLLEXPORT, #define DLLEXPORT __declspec(dllexport)
	- 필수는 아니나 우리가 작성한 Class가 외부에서 사용이 가능하다는 것을 의미함
	우리가 작성한 C++ 코드들도 엔진에겐 그저 수많은 모듈 중 하나일 뿐이고 다른 모듈에서 C++ 모듈의 내부 클래스에 접근하고자 한다면 <프로젝트명_API> 키워드가 붙어있어야 함

	- 비슷한 문법으로 #define WINAPI __stdcall, #define CALLBACK WINAPI등이 있는데
	갑작스레 함수 호출 규약에 대해 알아보면 (16에서 계속)

	16. cdecl, stdcall, thiscall 등이 있음
	- cdecl : Caller가 StackFrame 정리 -> 가변인자 가능
	- stdcall : Callee가 StackFrame 정리 -> 가변인자 불가능
	- thiscall : stdcall + this 전달(여기서 this란 클래스로 만들어질 인스턴스의 주소를 저장하는 this 포인터를 (미리) 제공하는 것)

	- cdecl, stdcall 공통점 : 오 -> 왼 으로 인자 읽어옴

	17. 결국 <프로젝트명_API>는 .dll인 것이고(동적 라이브러리) .lib(정적 라이브러리)와 비교하면
	- .lib : 속도가 빠르고 모든 기능을 제공하나 용량이 크다는 것이 단점이고 이 단점을 보완하기 위해 보통 동적 라이브러리를 사용함
	- 언리얼은 기능 별 수많은 .dll을 제공받아서(이렇게 제공받은 dll들을 <모듈>이라고 하는 것 같음)

	18. 카톡을 예로 들면 
	- .exe 파일을 눌러 프로그램을 실행하고자 할 때
	- 지정해둔 경로에 제공받아야 할 .dll중에 하나라도 없다면(경우에 따라 다름) 실행이 불가능함

	19. 클래스의 이름을 바꾸고자 한다면
	- 클래스 이름, 생성자, generated.h 파일(접두어x), .cpp에서 추가한 헤더의 이름, cpp에 구현 된 함수들의 네임 스페이스, 실제 파일 이름
	들을 모두 바꿔주어야 함
	- 바꾸고 빌드까지 해야 에디터에 반영 됨 -> ctrl shift b
	- 에디터에서 이전 내용이 표시되는 경우가 있는데(버그) 프로젝트 껐다 켜주면 됨

	20. 클래스를 삭제하고자 한다면
	- 안전하게 하고자 한다면 일단 sln과 에디터를 닫고

	- 경로 상 Source에서 h와 cpp를 찾아서 지워주고
	- .sln에서 존재하지 않지만 null을 물고 있는 h와 cpp도 지워주고
	- 빌드를 조지고 나면 에디터에서 없어지게 됨
*/