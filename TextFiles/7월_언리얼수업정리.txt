====
0703
====
	1. AddDynamic을 통한 델리게이트 바인드는 "::"이 필수임
	- 누구의 함수인지를 명확히 해야 함

	2. C에서 안되는 문법 한 번 보고 가자

	int const i = 5;
	int arr[i] = {0,1,2,3,4};

	- C++은 허용하는 문법이나 C는 안됨
	- 이유는 C++에선 const가 conextpr로 읽혀 컴파일 타임 이전에 i에 대해 상수로 인식시켜 줄 수 있으나
	C는 컴파일 타임이 되어서야 i가 const로서 값이 변하지 않는 불변변수가 되기 때문에 컴파일 타임 이전의 오류를 막을 수 없음

	3. 바인딩이 되어있다는 가정하에 델리게이트를 동작시키는 코드 2가지를 보면
	- 1) if(Trigger.IsBound()) Trigger.Execute();
	- 2) Trigger.ExecuteIfBound();

	4. NamedBox를 상속한 DelegateTrigger가 본인의 이름을 띄우지 못하는 문제가 있는데
	- NamedBox에서 Text->SetText(StaticClass()->GetDisplayNameText()); 이 코드가 문제임
	- 해결 : Text->SetText(GetClass()->GetDisplayNameText());

	- 다른 해결 버전들 : 
		Text->SetText(UKismetSystemLibrary::GetDisplayName(this)));
		Text->SetText(GetName());

	5. 4번의 내용을 사용함에 있어 알아야 하는 내용이 있음
	- 생성자의 this는 본인을 호출하는 것임 -> 자식에서 생성자를 부름에 있어 A -> B -> C 로 상속을 시켰다 했을 때 생성자가 불리는 순서는 A -> B -> C 임
	A의 생성자가 사용됨에 있어 C는 아직 초기화가 안 되어 있기 때문에 접근이 불가능함

	- 그렇다면 4번에서 GetClass()를 했을 떄 자식의 클래스를 얻어 올 수 있었던 이유는
	UObjectBase에서 멤버변수로 최종 상속받은 클래스를 UClass* 타입으로 들고 있는 엔진의 설계방식 덕분임 -> GetClass()는 UClass* 타입의 멤버변수를 return하는 함수

	- 추가로 UObjectBase가 Actor보다 상위 클래스이고 GetClass()가 오버라이드 되지 않은 함수였기 때문에 UObjectBase가 정의한 내용이 그대로 불려질 수 있었음

	- 생성자에서 어떤 함수를 불렀을 때 자식에서 오버라이드 된 함수라면 오버라이드 된 내용이 아니라 생성자를 만들고 있는 그 클래스의 버전 함수가 불릴 것임

	6. TEnumAsByte를 사용함에 있어 전방선언이 가능함(TEnumAsByte는 언리얼의 템플릿 버전 Enum임)
	- TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType; 멤버변수에 대해
	namespace EDrawDebugTrace { enum Type; }

	7. float 자료형에 대해 10의 몇승 이런 표현
	- float MyFloat = 1e5f;
	-> 10의 5승이라는 뜻 ->100000

	- float MyFloat2 = 3e5f;
	-> 3 * 10의 5승이라는 뜻 -> 300000

====
0704
====
	1. TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;
	
	UENUM(BlueprintType)
	namespace EDrawDebugTrace
	{
		enum Type
		{
			None,
			ForOneFrame,
			ForDuration,
			Persistent
		};
	}

	- UENUM에 BlueprintType을 해야 블프에서 사용 가능
	- C의 문법 enum을 네임스페이스로 구분지어 enum class와 비슷하게 사용

	2. enum이나 enum class나 따로 타입을 정하지 않으면 int 형인데(4byte)
	- enum class TestType : uint8 같은 문법으로 타입의 크기를 정해줄 수 있음
	- 추가로 enum에 정의한 열거자들이 순서대로 0,1,2,... 이런 literal 값들을 가지게 되는데
	이 literal조차 명시한 타입의 크기만큼 잡히게 됨

	3. 접미어 u는 unsigned int, ul은 unsigned long, ull은 unsigned long long

	4. unsigned long operator ""_deg(int i)
	{
		return i;
	}

	- 접미어의 오버라이딩을 하여 1_deg;는 int형이 아닌 unsigned long임
	- _(언더바)는 표준과 겹치는 이름이 될 수도 있으니 권고사항 -> 언리얼 프로젝트는 빌드 오류를 냄

	5. UENUM(BlueprintType)은 : uint8이 강제 됨
	- enum은 BlueprintType이 붙게 되면 enum의 선언에서 : uint8이 강제되는 것은 아니지만 사용함에 있어 TEnumAsByte<>를 거쳐 사용하고
	- enum class는 BlueprintType이 붙게 되면 선언에 : uint8이 강제됨 -> 빌드 오류가 나버림

	- UENUM(BlueprintType)을 사용하게 되면 namespace + enum 을 사용하고 TEnumAsByte까지 사용하는 것이 번거롭지만 나아보임

	6. #include <Kismet/GameplayStatics.h>는 Gameplay에 대한 class 내부의 static 함수들의 모임
	- 사실 상 전역 함수
	- 임시로 DelegateTrigger를 찾기 위해 UGameplayStatics::GetActorOfClass(this, ADelegateTrigger::StaticClass())로 찾았음

	7. #include "Particles/ParticleSystemComponent.h"
	- 파티클은 헤더 경로가 이런데 자주 쓸 거 같으니 외우도록

	8. Particle->Activate(true);
	- true의 파라미터 네임은 bReset임 -> true라는 건 활성화 돼 있는 중에 이 코드가 불리면 다시 시작한다는 뜻
	- 기본값은 false임

	9. GetActorLocation은 내부적으로 RootComponent의 Location을 얻어 옴

	10. 스태틱 메쉬의 모빌리티가 스태틱이라면 이동 관련 코드에도 영향을 미침 -> 무버블로 변경
	- SimulatePhysics로 바꾸면 Collision Preset이 PhysicsActor로 바뀌고 조명도 무버블로 자동으로 바뀜

	11. SphereOverlapActors C++ 버전 사용
	
	UKismetSystemLibrary::SphereOverlapActors
	(
		this,
		GetActorLocation(),
		500,
		{ EObjectTypeQuery::ObjectTypeQuery4 } ,
		AActor::StaticClass(),
		{ this },
		OutActors
	);

	- EObjectTypeQuery에 대해 ObjectTypeQuery4를 준 건 ObjectType이 PhysicsBody인 물체와의 충돌 검사임

	- ECollisionChannel, EObjectTypeQuery, ETraceTypeQuery 콜리전 관련하여 이렇게 3가지 열거자를 언리얼에서 제공하는데 각각 쓰임 방법이 다름

	1) ECollisionChannel : 엔진이 제공하는 기본 ObjectType 6개 + Channel 2개 + 엔진이 예약한 채널 6개 + 우리가 프로젝트 세팅에서 직접 정의할 수 있는 커스텀 채널 18개, 
	총 32개의 채널에 대해
	ObjectType에 대해선 각각 이름으로 접근 가능 ECC_WorldStatic, ECC_WorldDynamic, ECC_Visibility 등
	우리가 커스텀 정의한 채널들에 대해선 정의한 순서대로 ECC_GameTraceChannel1, ECC_GameTraceChannel2, ... 로 접근 가능

	이 때 유의할 점은 Object이건 Channel이건 구분 없이 정의한 순서대로 <Config - DefaultEngine.ini>에 적혀 있음

	Object1 - Channel1 - Channel2 - Object2 순으로 새로운 콜리전을 정의하게 되어도 만든 순서대로 ECC_GameTraceChannel로 구분지어 짐

	2) EObjectTypeQuery : 콜리전이 Object와 Channel에 대해 크게 구분지어지기 때문에 EObjectTypeQuery는 ObjectType에 대해서만 접근 가능함
	ObjectTypeQuery1, ObjectTypeQuery2, ObjectTypeQuery3, ObjectTypeQuery4, ... 이렇게 접근되어지는데
	기본적으로 ObjectTypeQuery6까지는 엔진이 기본 제공하는 ObjectType임(ObejctTypeQuery1 : WorldStatic, ObejctTypeQuery2 : WorldDynamic, ObejctTypeQuery3 : Pawn 등)
	순서로 유추가능하고
	ECollisionChannel과 다르게 Custom ObjectType들에 대해선 Channel과 관계없이 ObjectType이 추가된 순서로만 구분한다

	ex) Object1 - Channel1 - Channel2 - Object2 순으로 콜리전에 대해 커스텀 정의가 생기게 되면 
	ObjectTypeQuery7 : Object1 이고
	ObjectTypeQuery8 : Object2 인 것임

	3) ETraceTypeQuery : 2번의 설명에서 Obejct와 Channel의 차이를 이해한다면 같은 방법임

	ex) Object1 - Channel1 - Channel2 - Object2 순으로 콜리전에 대해 커스텀 정의가 생기게 되면
	TraceTypeQuery3 : Channel1
	TraceTypeQuery4 : Channel2

	12. 참고로 엔진에서 사용자 정의 채널에 대해선 #define COLLISION_WEAPON ECC_GameTraceChannel1 과 같은 매크로를 사용할 것을 권고함
	- ex. #define OBJ_COLLISION_OBJECT1 EObjectTypeQuery::ObjectTypeQuery7
	- ex. #define CHN_COLLISION_CHANNEL1 EObjectTypeQuery::TraceTypeQuery3

====
0705
====
	1. impulse는movement 계열 component 혹은 primitive component를 상속받은 컴포넌트에 줄 수 있음
	- Mesh->AddRadialImpulse();
	- 위 함수는 PrimitiveComponent의 함수

	2. 축 매핑 중 LookUD는 Scale -1 줬는데
	- 아마 PlayerController에서 yaw,pitch, roll 중에 pitch 관련 옵션 기본값이 혼자 -2.5 였던 값이 있는데 아마 기본 컨트롤러에 대해 고려해서 이렇게 만든 듯

	3. 키 입력을 함수랑 엮어주기 위해 Character의 SetupPlayerInputComponent()에서
	- PlayerInputComponent->BinxAxis("MoveFB", this, &Acharacter::MoveFB); 로 처리할 수 있음

	- 매크로로 간단히 만들면 #define BindAxisAuto(FunctionName) BindAxis(#FunctionName, this, &ThisClass::FunctionName) ... #undef BinxAxisAuto

	4. FRotator는 FQuat를 래핑한 클래스 이기 때문에 GetForwardVector()가 불가능함
	- FRotator에서 quaternion을 불러서 quaternion에 대해 forwardvector를 얻어야 함

	5. AMyCharacter를 블루프린트 AMyMyCharacter로 만들고 나서 외형 및 위치, 방향 잡아주고 나서 그 캐릭터로 게임을 하려면 GameMode에서 DefaultPawnClass로 잡아줘야 함
	- 기본 제공 되는 GameMode에서 DefaultPawnClass = ?; 를 해줘야 하는데 우리가 지정할 캐릭터가 블루프린트 타입임
	- 생성자에서 처리하기 위해선 ConstructorHelpers::FClassFinder<APawn> MyPawn(TEXT("AMyMyCharacter 블프 경로_C")); 로 얻어온 후
	- if(MyPawn.Succeeded()) { DefaultPawnClass = MyPawn.Class; }

	6. TSubclassOf를 클래스 래퍼런스라고 볼 수 있으나
	- 더 정확히는 UClass가 클래스 래퍼런스임

	- 둘의 차이 : UClass는 딱 그 타입만 / TSubClassOf는 상속받은 애들까지 체크 가능

	7. springarm, camera 헤더 외우기
	- #include <Gameframework/SpringArmComponent.h>
	- #include <Camera/CameraComponent.h>

	8. CreateDefaultSubObjectAuto(SpringArm)->SetupAttachment(GetRootComponent());
	- 생성과 동시에 붙이기

====
0706
====
	1. PrimitiveComponent란?
	- 형태를 가지는 컴포넌트
	- 메쉬 계열 혹은 콜리전 계열

	2. SetupPlayerInputComponent의 주석을 보면 functionality라는 단어가 있는데
	- input시 기능을 묶는다는 의미를 표현하기 위해 기능을 뜻하는 function을 쓸 수도 있었지만 function은 다른 의미로 해석될 수 있으니 이런 단어를 쓴 것으로 보임

	3. 함수에 대해선 정의로 이동(F12) 혹은 호출 계층구조 보기(Ctrl T) 하면 어떤 내용인지를 확인할 수 있고
	- 변수에 대해선 모든 참조 찾기(Shift F12)로 엔진 내부 구현을 살펴볼 수 있음
	- 모든 참조 찾기에 대해선 범위를 지정할 수 있는데(현재 문서 혹은 전체 솔루션 등등)
	- CharacterMovementComponent의 Velocity같은 변수는 굉장히 많이 쓰이고 있으므로 모든 참조 찾기를 눌렀다간 렉 걸려 재부팅할 경우도 생김

	4. 조건을 표현하는데 있어서
	1) if(PendingImpulseToApply.Z != 0.f || PendingForceToApply.Z != 0.f)
	2) if( ! (PendingImpulseToApply.Z == 0.f && PendingForceToApply.Z == 0.f))

	두 구문은 같은 의미를 같지만 강사님은 2번을 선호하신다고 함
	사실 나는 1번이 더 잘 읽힘

	5. Movement 계열의 ApplyRadialImpulse를 좀 더 알아보면
	- Radial에 대해 처리 후 ApplyImpulse로 처리 됨 -> 이런 처리가 일원화이며 이런 구성이 좋은 구성

	- 멤버 변수인 PendingImpulseToApply 변수를 한 프레임동안 팍 올렸다가
	- Velocity에 더해준 후 PendingImpulseToApply는 다시 0값을 가지게 됨
	- Pending이란 뜻이 '보류'라는 뜻을 가짐에서도 유추할 수 있으며 실제 엔진 내부에서도 위 설명과 같이 구현되어 있음

	- 추가로 CharacterMovementComponent의 Velocity는 OldVelocity 혹은 LastUpdateVelocity 등 다른 변수의 값을 정하는 곳에도 쓰이고 있음(Velocity 그 자체로 속도를 정하는 것은 아닌 것 같음)

	6. 헤더를 추가함에 있어 #include "" 혹은 #include <>의 2가지 경우가 있는데
	- "" : 현재 파일 기준으로 먼저 탐색 후 지정 된 경로를 탐색
	- <> : 지정 된 경로를 탐색

	- 지정 된 경로라 함은 VS에서 <속성 페이지 - VC++ 디렉터리 - 포함 디렉터리>와 같은 곳에서 미리 정해둔 경로를 의미

	- 앞으로 언리얼헤더는 <>, 우리 프로젝트 헤더는 ""로 사용하여 구분짓기로 함

	7. 애니메이션을 적용해주기 위해 AnimInstance를 상속하여 MyAnimInstance를 만듬(C++)
	- 이 클래스가 해줄 작업은 블프 이벤트 그래프에서의 로직을 대신 처리하여 변수를 다루기 위함임
	- BlueprintUpdateAnimation을 사용하여 매 프레임 업데이트 하던 내용을 C++로 처리해주어야 함

	- BlueprintNativeEvent로 되어서 C++내용을 블프에서 오버라이드하는 식으로 처리할 줄 알았으나
	
	- C++에서는 NativeUpdateAnimation을 오버라이드하여 우리의 변수를 업데이트 시켜줄 수 있음
	
	- 어떤 함수를 사용할지가 막막할 때 virtual 키워드를 찾는 것이 좋아 보임

	- 위와 같은 함수를 인터페이스처럼 제공했는데 이런 경우 접근 지정자에 대해선 부모의 접근 지정자를 따라가는 것이 좋음

	- 접근 지정자 symbol을 구분지을 때 public은 우하단에 아무것도 안 붙어있었는데 좌하단에 화살표가 붙어있는 것은 다른 파일에 정의가 있다는 뜻임
	(NativeUpdateAnimation은 좌하단엔 화살표, 우하단엔 아무것도 x -> 정의는 다른 파일에 있고 접근 지정자는 public이라는 뜻)

	8. 오버라이드 시 부모가 붙여둔 const는 자식에서 무조건 지켜져야 하지만 부모가 안 붙여둔 const를 자식에서 더 붙인다고 문제가 되진 않음

	9. auto로 변수를 받는 경우는 우측의 값이 명백한 경우
	- 명백하다는 건 함수 이름에서 티가 나는 정도라고 할 수 있을 듯

	10. Actor에서 GetVelocity를 받을 수 있기 때문에
	- GetOwningActor()로 받아서 처리하는 것도 낫배드(TryGetPawnOwner() 대신)
	
	11. C++에 우리가 정의한 AnimInstance를 애님 블프로 만들기 위해선
	- 콘텐츠 브라우저 우클릭 - 애니메이션 - 애니메이션 블루프린트로 만들어주어야 함
	- 다른 C++을 블프로 만드는 방식으로 하면 안됨

	12. 멀티캐스트 델리게이트는 반환값이 void여야만 함
	- 호출 순서가 보장이 안 되기 때문에 반환값을 배열에 담아서 돌려준다던가 하는 방법도 불가능

	13. 싱글캐스트 델리게이트가 반환값을 받기 위한 문법은
	- DECLARE_DELEGATE_RetVal_OneParam(int, FTriggerType1, int) 임
	- 반환값을 return받기 위해선 ExecuteIfBound 대신 IsBound()를 체크 후 Execute()함수를 통해 반환값을 반환 받을 수 있음
	- ExecuteIfBound()는 반환값이 bool 고정

	14. 델리게이트는 NineParams가 최대이며 OneParam 이후 TwoParams 이후 부터는 's' 붙이는 것 유의

	15. 월드 상 큐브 125개에 대해 전체 클릭 후 우클릭 액터 병합 + 폴더에 담아두어 월드 상 액터에 대한 관리도 해두었음

====
0707
====
	1. 멀티캐스트 델리게이트를 만드는 방법
	- TMultiCastDelegate<void(int)> a;
	혹은
	- DECLARE_MULTICAST_DELEGATE_TwoParams(FMultiTriggerType, int32, FLinearColor)

	2. UBT와 UHT는 전처리보다 더 먼저 진행되는 언리얼만의 빌드 방식임
	- UBT : Unreal Build Tool
	- UHT : Unreal Header Tool

	- UHT가 먼저 UCLASS(), UFUNCTION()같은 키워드들을 읽고 먼저 처리를 하기 때문에 ClassName.generated.h가 전처리로 파일에 포함되는 과정에서 문제가 없었던 것임
	- 출력을 확인해보면 위 내용을 확인할 수 있으며 <출력>이 주는 정보가 생각보다 많음

	3. public을 위로 올리는 건 습관화
	- 보기 편하기 위해

	4. 컴포넌트를 일반 배열로 만들고 UPROPERTY()로 리플랙션으로 노출시키려고 하면 첫 번째 인자를 제외하곤 적용받지 못함
	- TArray<> 사용하자
	- 혹은 컴포넌트는 배열로 만들지 말자

	5. 머티리얼을 받는 자료형 중에 UMaterialInterface가 있음
	- 동적 머티리얼은 UMaterialInstanceDynamic임
	- 머티리얼의 변수와 상호작용을 하기 위해선 UMaterialInstanceDynamic 자료형이어야 함(Cast)
	- 머티리얼 변수를 통제할 땐 실제 머티리얼에 있는 변수 이름이여야 하며 문자열로 넘겨주는 것이 단점

	6. FString과 FName이 암시적으로 변환될 수 있는 것 같으나
	- 생성자에선 explicit인지 확인 필요

	7. meshes[i]가 문자열로 그대로 읽히는 현상에 대해 ADDDYNAMIC, BINDDYNAMIC 쪽 참조

====
0710
====
	1. 블프 에디터의 컴포넌트 이름을 변수의 이름으로 띄울지 말지를 정할 수 있음 (사실 TMI)
	- 에디터 개인 설정 -> 일반 -> 외형 -> 네이티브 컴포넌트의 기저 이름 표시

	2. #define TestMacro(...) FString::FromInt(__VA_ARGS__)
	- 가변인자로 아무것도 넣지 않게 될 경우 FSTring::FromInt()가 되기 때문에 에러임
	
	3. 문자열은 ""끼리 붙여서 사용 가능
	- "a"" ""b" = "a b" 임
	혹은
	- "abc""def" = "abcdef" 임

	4. execDynArrayAdd()라는 함수를 과제하다가 보았는데 어떻게 생겼는지 궁금해서 타고 들어가보니 반환형이나 매개변수들을 동일시하고
	함수 이름에만 차별을 두어서 엔진에서 정의해 둔 함수였음

	- 실제 구현부가 어떻게 되었는지 궁금하였지만 UObject 관련 cpp가 굉장히 많기 때문에 그 안에 어딘가에 있는 걸로 마무리 함
	- 저런 매크로가 반복 작업을 줄이는 데에는 좋지만 사용하는 입장에서 F12로 찾아갈 수가 없으니 불편하기 함

	5. 머티리얼의 변수는 문자열로만 통제가 가능함
	- 머티리얼에 있는 변수 '이름들'을 가져올 수는 있으나 '이름들'을 어떻게 활용할 지는 사용자의 몫

	6. TArray를 크기를 먼저 잡고 인덱스로 접근하기 위한 방법은
	- TArray<int> MyArray; 일 때
	- MyArray.AddDefaulted(10);

	- 사실 동일한 동작을 Reset이나 Reserve도 했을 것 같으나 Reserve의 주석에 after allocation 이라는 설명 때문에 아니라는 게 왜인지는 모르겠음

	7. MulticastDelegate가 Broadcast를 함에 있어 바인드 되었던 인스턴스가 삭제되어도 크래쉬가 안 남
	- 하지만 객체가 삭제 되었어도 바인드 자체가 사라지는 것은 아님
	- 객체가 소멸되는 시점에 언바인드를 해주어야 함(소멸자 혹은 OnDestroy)

	- 가비지 컬렉터가 동작하는 것도 확인해 볼 수 있었음
	- 가비지 컬렉터를 강제 동작시키는 명령어도 있었던 걸로 기억하는데 뭐였더라

	8. 공식 문서에서 MulticastDelegate 사용에 있어 매개변수로 래퍼런스를 넘겨 초기화를 하고자 하는 사용법은 bad라고 함

====
0711
====
	1. TArray를 채우는 방법은 여러가지
	- AddDefaulted
	- Init
	- Emplace(생성 즉시 배열에 대입)
	- Add(생성 후 복사로 배열에 대입)

	- 문서 왈 : empalce가 add보다 성능이 떨어질리 없지만 가독성 면에서 add가 나을 것이니 가벼운 건 add, 그 외엔 emplace 사용

	2. 뜬금 질문으로 생성자에 : Super()가 안 붙는 이유는 인자가 없는 생성자는 명시적으로 안 써도 됨
	- 부모의 인자가 있는 생성자를 사용하고 싶은 경우엔 : (이니셜라이저)를 사용하여 초기화
	- 이니셜라이저(:)를 사용하여 TArray같은 멤버변수도 초기화 할 수 있음
	ex. TArray<int> MyInt;가 있다면 MyClass() : MyInt(10, 3) {} 처럼 -> MyInt(10,3)은 TArray의 생성자를 활용한 것 -> 크기는 3만큼 각 원소는 10으로 초기화

	3. 라인 트레이스(Objects, Profile, Channel)
	- #include "Kismet/KismetSystemLibrary.h"
	- UKismetSystemLibrary::LineTraceSingleByObjects();

	- 라인 트레이스 시(함수이름 끝이 Objects인 것) 어떤 Object와 충돌인지 검사하기 위해 ObjectTypeQuery인가 열거형을 넘겼어야 하는데
	ECollisionChannel과 ObjectType 간에 변환을 해주는 Convert 함수가 있음(UEngineTypes의 static 함수)

	- ECC_Pawn의 경우 ObjectTypeQuery3과 매칭됨
	- ECC와 Object, Chanel간의 채널에 대해선 3,4일 전 정리에서 설명한 적 있음(사용자 설정 object, channel 관련해서도 적혀 있음)

	4. Kismet에 있는 라인 트레이스는 사용을 간편화 해주는 래핑 함수
	- 무슨 말이냐 ? : GetWorld()->LineTraceSingleByObjects(); 로도 라인 트레이스를 할 수 있으나 넘겨야 하는 인자가 까다롭기 때문에 이것을 간편화해주는 함수인 것임

	5. LineTrace 시 hit한 actor가 character로 cast가 성공하면 LaunchCharacter를 하게 되는데
	- LaunchCharcter는 Character.h의 함수이고
	- 내부적으론 캐릭터의 MovementComponent를 찾아 MovementComponent::Launch()를 콜해서 동작하는 방식이며
	- BlueprintImplementable 함수인 OnLaunched()를 부르며 마무리 함 -> OnLaunched를 블프에서 오버라이드하면 launch를 call 했을 때 callback되는 일종의 델리게이트같은 작동인 듯

	6. CreateDefaultSubobject를 배열 버전으로 만든 매크로 사용 시 좌측 값으로 배열의 인덱스에 값을 대입하는 방식이기 때문에
	- TArray를 사용함에 있어 배열의 크기를 먼저 잡아놓지 않는 이상 오류가 날 수 있음 -> 매크로라 알아채기도 힘들 수도

	7. 6번이 좌측에 배열의 인덱스를 먼저 잡아놓은 매크로여서 오류가 난건데
	- 좌측을 뗀 버전을 먼저 만들고
	- 좌측 값도 넣은 버전을 만들 땐 좌측을 뗀 버전과 합쳐서 매크로를 만든다면 나름 깔끔한 코딩이라고 할 수 있겠음

====
0712
====
	1. TArray의 생성자 중 복사로 넘어가는 값에는 nullptr을 넘기면 안 됨 -> 다른 생성자 찾아야 함

	2. 오랜만에 나온 초기화 방법 3가지, copy, direct, uniform
	- copy : =
	- direct : ()
	- uniform : {}

	- uniform은 셋 중 제일 엄격하며 엄격하기 때문에 추천하는 초기화 방식
	- double d{3.4f}; 같은 초기화는 경고가 아닌 에러를 냄

	3. 인터페이스 생성은 언리얼 마법사로 가능함
	- <모든 클래스 표시>가 아닌 곳에서
	
	4. C++ 인터페이스는 UInterface를 상속받은 U 접두어가 붙은 클래스와
	아무 상속도 받지 않은 접두어가 I인 클래스 2개를 작성하게 됨
	- UINTERFACE()로 리플랙션에 노출은 U접두어 클래스가 해주고
	- 우리가 작성할 함수들은 I 접두어가 붙은 클래스에 적게 됨

	5. 블프의 인터페이스 = 순수 가상 함수 <-> C++의 인터페이스는 가상 함수도 가능하며 static도 가능

	6. I접두어 인터페이스에서 C++ 키워드인 abstract가 가능한데 그 이유는 리플랙션에 적용받지 않고 엔진에서 인스턴스를 안 만들기 때문에 가능함
	- abstract 사용엔 주의할 점이 있는데 I 인터페이스를 상속한 클래스에서 바로 abstract 키워드가 붙은 함수를 구현해주어야 함(클래스를 하나 건너뛰고 구현하면 에러)
	- 아니라면 상속받은 클래스가 abstract 키워드를 사용하게 되는데 리플랙션에 노출된 클래스라면 엔진이 인스턴스 1개 이상을 강제하기 때문에 이 과정에서 에러가 남

	7. 언리얼의 인터페이스 사용은 다중 상속으로
	- , public IMyInterface

	8. #include의 경우 선언 위치가 파일의 맨 위여야만 하는 것은 아님
	- 헤더가 필요한 곳에서 include해서 쓰는 것이 나은 경우가 있을 수 있음
	- 클래스 사이에 #include 적어서 쓰는 기법도 많은 듯

	9. 인터페이스의 기본 사용은 인터페이스의 헤더를 추가 후 인터페이스로 Cast하여 사용하면 됨
	- Cast의 유효 체크 후 사용하면 안전한 사용이 되겠음

	10. 가벼운 인터페이스 헤더를 추가함으로서 컴파일 타임을 줄이는 것만으로도 장점이라고 볼 수 있겠음
	- 언리얼 헤더들이 워낙에 무겁다 보니

	11. 인터페이스를 원래 인터페이스의 정의에 맞게끔 순수가상으로만 구성하고 싶다면
	- 1) abstract : C++ 문법이며 IInterface가 리플랙션에 노출되지 않아 가능, 하지만 상속받은 클래스들이 한 다리 건너뛰고 구현하면 에러
	- 2) PURE_VIRTUAL(FUNCTION_NAME) : 함수 구현부를 가지는 매크로이며 구현부가 실제 코드상에서 불리게 되면 LowLevelFatalError를 일으켜서 이 함수는 오버라이드가 강제됨
	- 3) unimplemented() : check(assert)를 포장한 매크로, check는 크래쉬를 일으켜 엔진을 중지시키는 언리얼의 assert 구문
	
	- PURE_VIRTUAL을 추천하는 이유는 어떤 함수에서 크래쉬가 난지 알려주는 관점에서 좋을 것 같음

	12. 간단한 복습으로 BlueprintNativeEvent, BlueprintImplementableEvent는 함수 원형을 virtual로 적으면 안 됨
	
	13. 인터페이스의 BlueprintNativeEvent 구현을 알아보면
	- _Implementation이 인터페이스의 기본 구현을 가진다면 기본 구현을 하고 아니라면 (PURE_VIRTUAL) 처리를 하여도 됨
	- 인터페이스를 상속하는 클래스에선 _Implementation을 오버라이드 하면 됨
	
	- 함수의 원형은 인터페이스에만 갖고 있으면 됨

	14. BlueprintNativeEvent, BlueprintImplementableEvent가 붙은 함수는 call을 할 때 일반 함수들과는 불리는 방식이 다름
	- IMyInterface::Execute_MyFunction(UObject* O);
	- 여기서 UObject로 넘겨주어야 하는 객체는 인터페이스를 구현한 클래스여야 함 -> 아닐 경우 check로 걸러 냄
	- 인터페이스를 블프에서 오버라이드 하려고 하는 경우 C++에서 그 함수를 부를 때
	Execute_ 가 붙은 static 함수 사용이 강제되는데 그 이유는
	함수의 원형과 _Implementation이 붙은(BlueprintNativeEvent) 함수는 gen.cpp에서 그 함수를 부를 경우 에러를 내게끔 만들어 놨음

	15. 추가로 라인트레이스시 FHitResult에 담기는 Actor는 약포인터이기 때문에 .Get()을 해야 함
	- 혹은 Actor를 날포인터로 넘겨줄 수 있는 GetActor()를 HitResult로부터 부를 수도 있음

	16. Blueprint에서 쓰게 끔 만들어 놓은 함수의 경우 (Native, Implementable) 함수 이름에 접두어로 K2_가 붙여서 식별하는 경우가 많은 듯(Kismet 2?? 뭐 이런 뜻이라나)
	- 블프에서 K2_ 가 붙게 되면 거슬릴 수 있으니 UFUNCTION()의 메타 지정자 중에 meta = (DisplayName = "NoK2Version") 로 블프에 보여질 이름을 바꿀 수도 있음

	17. 16번을 적다보니 생각난 건데 K2_ 버전이 있다면 인터페이스에 K2접두어가 없는 버전을 만들어 K2_가 붙은 버전을 부르는 함수를 만들면 되겠음

====
0713
====
	1. C++의 MyInterface를 블프의 BP_Explosion에 상속 후 (C++의 인터페이스를 블프에 직접 상속)
	- C++ 코드로 (Execute_) 실행시켜보려 했을 때 블프에서 그 함수를 오버라이드 하지 않았음에도 "블프에 함수 구현이 있는 걸 부르겠다" 라는 흐름으로 빠짐(gen.cpp)
	- 이 테스트 과정에서 UINTERFACE() 였던 것이 0순위로 의심됨(지정자를 채우거나) or native의 동작이 원래 그렇거나

	2. 솔루션 탐색기의 '검색'창 활용
	- '몽타주 재생' 노드의 정체를 밝히기 위해 '검색'창에 playmontagecallbackproxy 검색

	3. UPlayMontageCallbackProxy를 까보면
	- private으로 감추고 static 으로 선언한 PlayMontage 노드가 있음
	- 몽타주는 같은 몽타주여도 ID가 다름
	
	4. '몽타주 재생'의 출력 핀이 여러개일 수 있는 원리는 간단하게 말하면 'DynamicMulticastDelegate'임
	- AnimInstance가 갖고 있는 BlendOut, Interrupted, ... 등의 델리게이트에서 Proxy의 델리게이트를 호출하고
	- 우리가 연결해 놓은 핀들은 Proxy의 델리게이트에 바인드를 하게 되는 것

	- 위 과정을 거치면 우리의 애님 인스턴스가 몽타주마다 BlendOut, Interrupted,... 등의 상황에서 타이밍에 맞게(얘네도 델리게이트를 호출하는 것) Proxy의 델리게이트를 호출하는 함수를 호출하는데
	이 때 바인드되어 있는 것이 있다면 불리게 되는 것(Broadcast)

	- '몽타주 재생' 자체가 Proxy임 -> 이 노드가 불리는 만큼 Proxy가 만들어지게 된다고 보면 됨
	- 걸어놨던 내용은 '몽타주 재생' = Proxy 가 Destroy 되는 시점에 모두 Unbind 하게 됨

	5. Proxy : 중개자 정도의 의미로 받아들이면 됨

	6. 각각의 출력 핀(흐름)들은 UPROPERTY(BlueprintAssingable)로 걸려있어 우리가 거는 흐름은 다이내믹 멀티캐스트 델리게이트에 '할당' 하게 되는 것과 마찬가지
	- UPROPERTY(BlueprintAssingable) : dynmulticastdelegate를 블프에서 '할당'할 수 있게 만드는 키워드임
	- 이게 핀으로서 출력될 수 있었던 이유는 UObject - UEdNode - K2Node - ,... - K2Node_PlayMontage 로 상속받은 구조 자체로 엔진에서 처리를 해주는 듯
	- 위에서 설명한 Proxy도 K2Node_PlayMontage가 참조하는 형태로 가지고 있고 실질적으로 K2Node_PlayMontage가 Proxy를 만들어서 처리하는 듯

	7. Proxy를 만들어서 부르는 '몽타주 재생' 이건 Character의 함수인 PlayAnimMontage이건 결국엔
	- AnimInstance의 MontagePlay를 내부에서 부르고 있음
	- 결국 AminInstance의 MontagePlay가 끝판왕임 -> 얘 부르면 됨

	8. uasset의 경우 Content 이후의 경로만 망가뜨리지 않는다면 '이주'가 아닌 폴더에서 복사나 이동으로 넘겨줘도 됨

	9. 에디터 유틸리티 - 에디터 유틸리티 블루프린트가 있음
	- 에디터에 기능을 더 추가해줄 수 있는 듯

	10. 애니메이션을 다룸에 있어 블프가 아쉬운 점은
	- MetaData를 다룰 수 없음

	- 애니메이션 에디터에서 배열로 추가해 줄 수 있고
	- MetaData 클래스를 만들어서 그 클래스를 위 배열에 추가해 줄 수 있음
	- 하지만 CPP에서나 처리해 볼 수 있는 듯

	- 애니메이션의 MetaData를 유용하게 쓸 수 있는 경우는 '공격 애니메이션' 자체가 공격 계수를 가지고 있어 원래 공격력에 배수로 데미지가 들어간다던가
	하는 애니메이션 단위로 처리가 가능함(다른 유용한 활용이 많을 듯)

	- 유틸리티 블루프린트에서는 'GetMetaData'를 가지고 올 수 있긴 함(인 게임내 적용 받을 내용이 아니라 애니메이션의 관리를 위해 여기에만 풀어놓은 것 같기도)

	11. 애니메이션 에디터에서 '커브'를 시간 별로 편집하게 되면
	- 애니메이션 블루프린트에서 'Get Curve Value'로 현재 애니메이션의 시점에서의 커브 값(float)이 얼마인지를 알 수 있음
	
	- 게임에 적용시키기 좋은 예는 공격 타이밍에 따라 데미지가 다르게 들어갈 수 있게끔 처리할 수도 있을 듯

