======
0619
======
	1. 블프 -> C++ 프로젝트 전환은 블프 프로젝트에서 그냥 C++ 클래스 만들면 됨

	2. .Net Frame Work 4.6.1 이상 설치해야 함
	- C++로 열기 위해선 필요한가 봄

	3. VS2023 버전은 지원 안 되는 것 같음

	4. C++ 프로젝트 경로엔 한글 안 들어가게 유의

	5. Unreal C++ 프로젝트는 실제 경로와 프로젝트 상 보이는 경로가 일치하지 않음
	- 폴더와 필터의 차이임
	- 엔진 소스들은 설치 경로 상 이곳 저곳 퍼져있기 때문에 편의를 위해 이렇게 제공하는 듯
	- 헤더와 cpp파일들은 좌측 하단에 파란 표시가 나는데 <weak ptr> 정도로 생각하면 될 듯 -> 변경사항은 다 반영이 되지만 삭제 시 프로젝트에서의 삭제일 뿐 실제 경로에서 삭제하는 것이 아님

	6. C++ 프로젝트는 Content, Config, Source, UProject가 필수 요소
	- .vs : vs의 인텔리전스에 대한 데이터베이스나 vs의 세팅 정보를 저장하는데 시간이 지나면 용량이 굉장히 커질 수 있으나 편의를 위해 프로젝트 진행 중엔 냅두는 것이 좋을 듯
	- Binaries : 사용자의 C++을 빌드한 목적 파일, .dll은 이곳에 있음(C++ 빌드 결과물)
	- Intermediate : 언리얼 헤더 툴에 의해 생성 된 generate.h 파일이 여기 있음, 프로젝트 기본 생성시에도 1GB정도 차지하는데 어떤 것이 있는지는 더 알아봐야 함
	솔루션 관련 파일들도 Intermediate에 생성 됨(.sln과 별도로 관리)
	- Saved : 차차 알아보도록
	- Source : 헤더, Cpp -> 우리의 메인 폴더

	- sln : vs의 프로젝트를 지워도 재생성가능 -> 폴더 경로의 .uproject에 우클릭 후 generate ... 누르면 새로 솔루션 만들어 줌

	7. 위에서 필터에서 지워봤자 실제 경로에서 지우는 것이 아닌 프로젝트에서 제외하는 거라 했는데 반대로 추가하려면
	- 위치 시킬 경로에 파일을 위치하고 필터에 드래그 해오면 됨
	- 혹은 프로젝트에 추가하는 단축키 활용

	8. 엔진에서 제공하는 헤더 혹은 cpp의 실제 경로가 궁금하면 그 파일에 대해 우클릭 후 경로로 이동 가능함

	9. <프로젝트명.h>가 어떤 용도인지는 알아봐야 함

	10. <프로젝트명.build.cs>는 모듈을 string으로서 추가하는 C# 코드
	- 기본 제공 모듈은 Core, CoreUObject, Engine, InputCore인데 Engine에서 대부분의 Conponents들을 포함시켜주는 것 같음(엔진 API 참고함) 
	- 블프에선 그냥 쓰던 AI 기능을 쓰고 싶으면 "AIModule"을 이 폴더에 문자열로 추가해줘야 함

	- Slate UI는 주석이 쳐져있는데 UI 프로그래밍하는 기능임 (html 같은 ?)

	11. 언리얼 C++마법사로 새로운 클래스(이번엔 액터였음)를 만들게 되면 VS상에선 외부에서 변경했다고 문구가 뜸
	- 변경사항을 반영해줘야 함

	12. 새 클래스의 맨 위 주석은 <프로젝트 세팅 - 법률 - 저작권 고지>에서 문구를 바꿀 수 있음

	13. 접두어를 간단히 알아보면
	- U : UObject
	- A : AActor
	- T : Template
	- F : C++

	14. C++에서 지원하지 않거나 엔진에 필요한 기능은 대부분 매크로로서 지원함
	- UCLASS(), GENERATED_BODY(), 프로젝트명_API 등

	15. 프로젝트명_API를 알아보면 -> #define 프로젝트명_API DLLEXPORT, #define DLLEXPORT __declspec(dllexport)
	- 필수는 아니나 우리가 작성한 Class가 외부에서 사용이 가능하다는 것을 의미함
	우리가 작성한 C++ 코드들도 엔진에겐 그저 수많은 모듈 중 하나일 뿐이고 다른 모듈에서 C++ 모듈의 내부 클래스에 접근하고자 한다면 <프로젝트명_API> 키워드가 붙어있어야 함

	- 비슷한 문법으로 #define WINAPI __stdcall, #define CALLBACK WINAPI등이 있는데
	갑작스레 함수 호출 규약에 대해 알아보면 (16에서 계속)

	16. cdecl, stdcall, thiscall 등이 있음
	- cdecl : Caller가 StackFrame 정리 -> 가변인자 가능
	- stdcall : Callee가 StackFrame 정리 -> 가변인자 불가능
	- thiscall : stdcall + this 전달(여기서 this란 클래스로 만들어질 인스턴스의 주소를 저장하는 this 포인터를 (미리) 제공하는 것)

	- cdecl, stdcall 공통점 : 오 -> 왼 으로 인자 읽어옴

	17. 결국 <프로젝트명_API>는 .dll인 것이고(동적 라이브러리) .lib(정적 라이브러리)와 비교하면
	- .lib : 속도가 빠르고 모든 기능을 제공하나 용량이 크다는 것이 단점이고 이 단점을 보완하기 위해 보통 동적 라이브러리를 사용함
	- 언리얼은 기능 별 수많은 .dll을 제공받아서(이렇게 제공받은 dll들을 <모듈>이라고 하는 것 같음)

	18. 카톡을 예로 들면 
	- .exe 파일을 눌러 프로그램을 실행하고자 할 때
	- 지정해둔 경로에 제공받아야 할 .dll중에 하나라도 없다면(경우에 따라 다름) 실행이 불가능함

	19. 클래스의 이름을 바꾸고자 한다면
	- 클래스 이름, 생성자, generated.h 파일(접두어x), .cpp에서 추가한 헤더의 이름, cpp에 구현 된 함수들의 네임 스페이스, 실제 파일 이름
	들을 모두 바꿔주어야 함
	- 바꾸고 빌드까지 해야 에디터에 반영 됨 -> ctrl shift b
	- 에디터에서 이전 내용이 표시되는 경우가 있는데(버그) 프로젝트 껐다 켜주면 됨

	20. 클래스를 삭제하고자 한다면
	- 안전하게 하고자 한다면 일단 sln과 에디터를 닫고

	- 경로 상 Source에서 h와 cpp를 찾아서 지워주고
	- .sln에서 존재하지 않지만 null을 물고 있는 h와 cpp도 지워주고
	- 빌드를 조지고 나면 에디터에서 없어지게 됨

======
0620
======
	1. StackFrame : 함수가 호출될 때 불린 함수만의 스택 영역을 구분하기 위하여 생성된 공간
	- <지역 변수>, <매개 변수>, <복귀 주소>를 저장
	- 함수가 끝나면 그 함수를 불러준 Caller(이전 함수)의 주소로 복귀함 -> 이 때 함수 호출 규약에 의해 Caller가 StackFrame을 정리할 지 Callee가 정리할 지 정하게 됨(stdcall, cdecl)
	- VS에서 기본값으로 설정해 둔 함수 하나 당 지역 변수의 공간은 1MB이다 -> 1MB는 1000000Byte이고 이 수치는 Int(4Byte) 250000(25만)개를 선언할 수 있는 수치임
	- int a[250001]; 은 불가능하단 뜻이고 이 이상의 공간을 할당하고자 한다면 동적할당을 하거나 VS의 기본값을 바꿔주어야 함

	2. 언리얼에서 문자열을 사용하기에 앞서
	- MBCS(Multi - Byte Character Set) : char (1Byte) -> 우리가 흔히 아는 아스키코드 생각하면 됨
	- UNICODE : wchar_t (2Byte) -> 온 지구의 모든 말을 담기 위해 문자 당 2Byte면 충분한가 봄(전에 알기로 문자 당 4Byte까지도 늘어날 수 있는 걸 봤었는데..)

	- 프로젝트의 성격에 따라 문자를 char 혹은 wchar_t로 받는 경우가 다른데

	- 이를 일반화 하기 위해 TEXT("나 문자열임 ㅋ")를 MBCS로 쓸지 UNICODE로 쓸 지 정할 수 있게 해놨다고 보면 됨

	- 간단하게는 어딘가에 프로젝트 세팅에서 바꿀 수 있겠지만 근본적인 코드로서 알아보자면

	#if defined _UNICODE
	#define TEXT(Text) L##Text
	#else
	#define TEXT(Text) Text
	#endif

	라고 보면 됨

	- L은 이 문자열이 유니코드임을 나타내고 ##은 문자열간에 구분을 위한 문법이라고 보면 됨

	3. 언리얼 C++의 디버깅 방법은 중단점을 걸고(F9) (혹은 코드의 좌측에 클릭) F5로 디버깅을 하게 되면 에디터가 새로 켜지게 됨
	- 이때 디버깅 하고자 하는 상황을 만들고(액터를 레벨에 배치한다거나) <플레이>를 하게 되면 중단점에 걸리게 됨

	- 위 방법이 번거롭다면

	- VS상에선 디버그가 진행 중(F5가 눌린 상태)이고 그 상태로 코드를 편집하고 나서 '저장' 후 에디터 상에서 '컴파일' 버튼을 누르고 에디터의 레벨을 '플레이' 해주면 됨
	- 근데 사실 이것도 번거로워 보이니깐 그냥 사양 좋게 맞춰서 필요할 때 마다 중단점 걸고 F5 누르고 '플레이' 할 것 같음

	4. 핫 리로드를 믿지 말고 에디터의 '컴파일' 버튼을 믿자 -> VS상 빌드보다 강력한 듯

	5. UE_LOG(LogTemp, Log, "문자열", 가변 인자)
	- 로그를 찍기 위해 3개의 인자 + 가변 인자를 넘기면 되는데
	- LogTemp : 로그의 제목, 로그의 맨 좌측 이름임
	- Log : Verbosity라고 하는데 Log의 정도? 얼마나 심각한가 정도를 찍어주는 거라고 보면 됨 -> Log 키워드는 이 표시를 안 하는 키워드인 듯
	- "문자열" : printf의 사용법과 같다고 보면 됨 -> 언리얼 식으로 쓰려면 TEXT("")를 사용하여 안전한 코딩하자

	6. 리플랙션 : 런타임에 클래스가 자기 자신을 조사할 수 있는 기능(어떤 변수가 있고 어떤 함수가 있고)
	- 현재 파악한 바로는 리플랙션이란 결국 UPROPERTY, UCLASS, UFUNCTION, UPARAM 등 언리얼이 제공하는 매크로들임
	- 리플랙션이 강력하긴 하지만 C++ 내부에서 사용하는 변수 혹은 함수에는 위 키워드들을 사용하지 않아도 됨
	- 리플랙션이란 결국 <에디터 혹은 엔진>에게 정보를 주는 것

	7. 변수에 UPROPERTY() 키워드를 붙여 리플랙션을 활용한다면
	- 일단 UPROPERTY가 없이 C++문법을 따라 작성한 변수는 에디터의 블루 프린트에 노출도 되지 않고 getter, setter 등 블프 상에선 아무것도 할 수 없음
	- UPROPERTY(EditDefaultsOnly) int i; 로 선언함으로서 블프의 클래스에서 이 변수의 기본 값을 편집할 수 있게 됨 -> Instance에서는 불가능
	- 다른 키워드들은 설명없이 나열만 하겠음
	- EditDefaultsOnly, EditInstanceOnly, EditAnywhere, VisibleAnywhere, VisibleDefaultsOnly, VisibleInstanceOnly, BlueprintReadOnly, BlueprintReadWrite 는 꽤나 자주 쓸 내용
	- BlueprintGetter = GetterFunctionName, BlueprintSetter = SetterFunctionName 이거는 한 번 써봄직 함

	- 위 키워드 중에 EditAnywhere -> VisibleAnywhere로 바꾸는 등의 작업을 하면 Instance별로 편집 된 값에 대해선 바뀌지 않는 의도치 않은 상황이 있을 수 있음

	- Edit과 Visible 시리즈는 공존할 수 없음

	- 문서 참조 : https://docs.unrealengine.com/4.26/ko/ProgrammingAndScripting/GameplayArchitecture/Properties/Specifiers/

	- Category = CategoryName 으로 체계적인 설계도 습관화하도록

	8. 함수에 붙는 지정자는 UFUNCTION()임
	- UFUNCTION(BlueprintCallable)을 함으로서 블루프린트에서 호출 가능
	- BlueprintGetter, BlueprintCallable, BlueprintImplementableEvent, BlueprintNativeEvent, BlueprintPure, BlueprintSetter 등

	- 문서 참조 : https://docs.unrealengine.com/4.26/ko/ProgrammingAndScripting/GameplayArchitecture/Functions/Specifiers/

	- UFUNCTION(BlueprintCallable, meta = DisplayName = "Blueprint Node Name")으로 블프 함수 이름을 대체할 수도 있는 듯
	- SpawnActorFromClass가 블프 버전에서 이런 이름인 건 위 방법으로 쓰인거 같음 -> C++ 버전은 SpawnActor<ClassName>()
	
	9. 프로젝트이름.h 는 <미리 컴파일 된 헤더> 정도의 용도임
	- 자주 추가할 헤더들이나 프로젝트 진행을 도울 매크로를 정의하여 사용

	- 기본으로 #include "CoreMinimal.h"가 <프로젝트이름.h>에 추가 되어 있는데
	언리얼 마법사로 Uobject 밑으로 생성하게 되면 헤더마다 맨 윗 줄에 CoreMinimal.h를 추가해주게 되는데 이걸 <프로젝트이름.h>으로 대체하여 사용하는 경우가 종종 있는 듯

	- CoreMinimal.h 에 대해선 4.x 버전 이후 IWYU(Include What You Use)로 엔진의 규모가 커지면서 컴파일 시간을 단축시켜주고자 정말 필요한 필수 헤더들만 포함한
	CoreMinimal.h만 포함하고 필요한 것들은 직접 cpp에 추가하여 사용하는 방법을 채택함

	- 4.x 버전 이전에선 Engine.h 혹은 EngineMinimal.h 등을 추가하여 거의 모든 헤더들을 추가하여 사용했다고 함

======
0621
======

