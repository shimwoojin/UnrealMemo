#pragma once
/*
	1. 다단히트 막는 과제 풀이를 진행함
	- 나는 BP_Weapon이 몽타주를 몇 번 재생했나를 알게해서 그 값을 비교하는 방식으로 다단히트를 막아봤는데
	- 다른 방법으로는 맞은 Actor의 CanBeDamaged를 껐다가 공격이 끝나는 노티파이에서 켜주는 식으로도 구성해봤지만
	CanBeDamaged 옵션은 잘 건드리지 않는다고 함
	
	2. 정답 풀이는
	- 무기의 Overlap 이벤트에서 Set에 겹친 Actor가 있는지 검사하고 없다면 Damage주고 있으면 넘어가는 방식
	- 검사 이후에 Set에 Actor넣어주고
	- 노티파이가 끝나는 시점에서 이 Set을 비워주는 방식 (어떤 노티파이여야 하냐 묻는다면 BP_Weapon의 Overlap을 꺼주는 Notify)
	- 노티파이를 override하는 것은 아니고 BP_Weapon의 함수에서 처리하는데 노티파이 End에서 돌고 돌아 결국은 이 함수를 처리하기 때문

	3. Set이 Hash로 만들어져 성능이 좋다라는 얘기가 나와서 시간복잡도를 다뤄봄
	- 복잡도는 시간, 공간으로 구분되지만 현대에는 시간복잡도를 더 중요시 함
	- 시간복잡도에 대해 빅오, 빅세타, 빅오메가로 구분할 수 있고 보통 빅오를 사용함
		- 빅오 : 최악, 빅세타 : 평균, 빅오메가 : 최악
	- 빅오의 성능 수준을 대략 써보면
		- O(1), O(logn), O(n), O(nlogn), O(n^2), ... O(2^n)
	- 빅오를 표기함에 있어 최고차항의 계수를 떼서 표시함

	4. 강사님이 O(n) 위로는 안좋다 라고 하시길래
	- 정렬이 아무리 빨라봐야 nlogn이기 때문에 그거 관련해서 물어봤는데
	- 기수정렬은 O(n)의 시간복잡도를 가지고
	- 기수정렬이 뭐냐라고 한다면
		- 일의 자리에 대해서 먼저 분류하고 십의자리, 백의자리 점점 자릿수를 늘려가며 그 자리수별로 분류하다 보면 정렬이 됨


*/