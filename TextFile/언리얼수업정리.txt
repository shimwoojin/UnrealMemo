! 모두저장은 습관화, ctrl + shift + s

================
0302, 0303, 0306
================
0. 레벨의 우측 상단에 스냅 옵션에서 t, r, s에 대해 모눈 종이처럼 끊어서 값을 세팅할 수 있게끔 기본값으로 잡혀있고 그 값에 대해 세팅도 가능하지만
풀어서 쓰는게 부드러워서 좋음
카메라의 속도도 제어 가능, 기본값은 4, 1

1. 액터 트랜스폼 변경 단축키 w : 트랜지션, e : 로테이션, r : 스케일

2. 블루프린트에서 흰색 선을 따라가는 게 함수를 호출하는 순서인 듯

3. 블루프린트 클래스의 변수 디테일에서 인스턴스 편집, 블루프린트 읽기전용, 툴팁, 스폰시 노출, 프라이빗, 시네마틱에 노출, 카테고리 설정 가능
 - 카테고리를 더 세분화하고 싶으면 | or 비트연산자 사용

4. 변수에 대해 getter, setter를 써야한다면 변수를 블루프린트로 끌어서 놓을 때 ctrl -> getter, alt -> setter임

5. 액터를 새로 만들고 나서 컴포넌트를 추가하면 default로 잡혀 있던 최상위 컴포넌트를 덮어씌우는 게 좋은데
 부모로 만들고 싶은 컴포넌트를 그 위치로 드래그해서 놓아주면 됨

6. 컨스트럭션 스크립트는 액터를 레벨에 배치했을 때 적용되는 그래프, 초기값 혹은 생성자의 느낌

7. 블프의 함수는 키워드를 지어주면 검색할 때 그 키워드로 찾아짐

8. 퓨어 함수는 원래의 목적이 로컬이 아닌 외부변수는 변경이 불가능하고 입력과 출력이 같은 함수에 대해 적용하는데
이것을 엔진에서 막아주지는 못하고 스스로 지켜야 하는 규칙이며
퓨어가 불리는 시점은 반환값이 쓰이는 시점임. 퓨어함수의 반환값을 여러군데에서 갖다 쓰게 되면 퓨어함수는 그만큼 호출되는 것이고
혹시라도 함수 내부에서 변경되는 값이 있다면 의도치 않은 결과가 있을 수 있음

9. 당연스럽게도 함수의 입력과 출력에 대해 핀을 만들 수 있고 언리얼 블프의 특징인 것인지 출력값은 여러군데에서 사용 가능
아마 출력값을 여러군데에서 가져다 쓰는 건 반환값에 대해 저장해놓는 변수를 따로 지정하지 않아도 엔진에서 저장해놓기 떄문이라 봄

10. begin play 이벤트는 레벨이 play되었을 때 실행, 액터마다 설정 가능

11. 블프 if문의 정식 명칭은 branch이고 검색 시 if 혹은 branch로 찾을 수 있음

12. 노드에 코멘트를 다는 것은 노드에 마우스를 갖다대면 왼쪽 상단에 말풍선이 뜨는데 거기서 가능, 우클릭 후 코멘트에다가 써도 가능

13. 노드를 연결한 선에 대해 따로 빼서 정리해야할 때 선에 대해 더블 클릭 후 생긴 경유 노드에 대해 alt클릭 후 드래그해서 빼낼 수 있음
만들 때 부터 경유노드를 지정해야 한다면 add reroute node가 풀네임인데 addre 이런식으로 검색 가능

14. ctrl클릭 후 노드들을 묶어서 c로 블록 단위로 노드들을 관리할 수 있고 색, 글씨 크기, 줌을 당겨서 멀리서 보았을 때도 보일지를 정할 수 있음
단축키 c가 아니라면 노드들을 클릭 후 코멘트 달기에 코멘트 달아도 가능

15. 구조체를 만드는 건 어렵지 않으나 구조체의 멤버를 따로 끌어다 써야한다거나 하는 세밀한 작업에선 다루는 방법을 알아야 함
구조체를 만들 때 단일 변수, 배열, set, map으로 만들지에 대한 값도 설정할 수 있음
bool변수였을 때는 set이랑 map이 잠겨있었는데 간단히 생각하면 set은 집합, map은 key-value구조이기 때문에 의미가 없으니 잠가놓은 듯
기본값도 설정 가능

16. 블프에서 구조체에 대해 만들기, 분해, 설정이 가능한데 각각 make, break, set members in <구조체 이름> 키워드 임

17. 만들기는 temp같은 역할을 하는 것으로 보임
temp이지만 노드에서 우클릭 후 변수로 승격 가능, 변수로 승격하게 되면 블프 클래스의 멤버변수가 됨

18. 구조체 클릭 후 pin option에서 핀 숨기는 기능 있음

19. 기본적으로 구조체의 멤버가 필요하다면 핀 분할로 개별 멤버를 끌어다가 쓸 수 있지만
구조체 자체가 필요하고 구조체의 멤버가 필요하다면 분해 기능을 쓰는 것이 좋아보임

20. make vector4의 경우 2가지가 나오는데 각각 non-custom, custom임
custom이 지원하는 기능이 더 많으나 non-custom이 깔끔하게 쓰기에 좋아보임
참고로 custom은 노드에 한글로 적혀있었음

21. 내가 쓰고 싶은 레이아웃을 저장할 수 있고 창 -> 레이아웃 관련 탭에서 불러오기, 저장 등 가능함
수업에선 콘텐츠 브라우저는 2개 띄우고 레벨을 크게 볼 수 있는 화면을 볼 수 있게끔 잡아놨음

22. level이랑 구조체, blueprint등은 폴더 단위로 관리하는 것이 좋아보임


======
0307
======
1. 에셋 추출해오는 방법
 - 콘텐츠 브라우저 -> 폴더 혹은 파일에 우클릭 -> 이주

$ 이주가 아닌 폴더 단위로 복사를 하게 되면 래퍼런스 관계가 깨질 수 있음

2. 와이어 프레임
 - 뷰포트에서 [라이팅포함]이 기본값, [브러시 와이어프레임]은 와이어 프레임 모드


3. 새 레벨 저장
 - <파일 - 새 레벨 - 원하는 레벨> 후 Ctrl + s로 레벨을 저장 후 하는 게 좋음

4. 엔진 컨텐츠 가져오기
 - 콘텐츠 브라우저에 뷰 옵션 -> 엔진 콘텐츠 표시 체크 후, 필터 옆에 소스 패널을 표시 엔진 콘텐츠에서 원하는 에셋 레벨로 끌어오기
 - 검색 가능

5. 액터 스케일 같은 비율로 키우기
 - 레벨의 액터 클릭 혹은 월드 아웃라이너에서 클릭 후 디테일 패널에서 트랜스폼의 스케일에 자물쇠 잠근 후 스케일을 늘리거나 줄이게 되면
 원래 가지고 있던 x,y,z 스케일의 비율만큼 동시에 조정 가능

6. 월드에 배치된 액터 이름 바꾸는 단축키, F2
 - 월드 아웃라이너에서 이름 바꿀 액터 우클릭 후 F2

7. 블루프린트 클래스는 BP 접두어

8. 캐릭터 블루프린트 클래스의 기본 포함 컴포넌트
 - 캡슐(콜리전), 애로우, 무브먼트, 매쉬

9. 로컬축은 -> +x, 화면에서 나오는 방향 +y, ^방향 +z
 - mesh 컴포넌트가 바라보는 방향과는 다름, mesh가 부모가 아님

10. 무브먼트에서는 물리 관련, 중력 정지 마찰 계수 등

11. scene component와 actor component의 차이
 - actor는 데이터를 다루는, scene은 트랜스폼이 있음

12. capsule이 액터의 루트 컴포넌트이기 때문에 로테이션이랑 트랜지션 설정이 안 떴음
 - 하위 컴포넌트들은 루트에 대해 상대적인 트랜스폼

13. mesh component에서 animation mode 설정 가능, 후반엔 자주 쓰는 건 아니라 함

14. game mode base에서 기본 pawn이나 기본 player controller등 설정 가능(클래스 디폴트)
 - 만든 game mode base에 대해서는 레벨에 적용 혹은 프로젝트 단위로 적용해주어야 함
  - 레벨 단위는 월드세팅에서, 프로젝트 단위로는 편집 - 프로젝트 세팅 - 맵&모드 - 기본 게임모드 값을 바꿔주어야 함

15. 빙의 탈출 단축키 F8
 - shift + F1 후 탈출 눌러도 됨

16. 캐릭터 몸 속에서 몸쪽이 비어보이는 이유는 pipeline의 rs단계에서 backface culling되었기 때문

17. gamemodebase에서 기본 pawn 설정해주었기 때문에 레벨 play하게 되면 player start지점에서 설정해준 pawn 리스폰 해줌
 - pawn을 레벨에 배치할 필요가 없다는 뜻, player start는 필요

18. character에서 monster와 player를 상속시켜주는 구조로 가기 때문에
 - mesh component애서 설정한 skeletal mesh를 none으로 해서 물려주고
 - 순수가상클래스로 만들어주는 세팅까지 해줌(BP_Character클래스의 클래스 옵션에서 Generate Abstract Class 옵션 켜줌, 순수가상클래스화)
 - Character의 자손 클래스를 만들때는 콘텐츠 브라우저에서 우클릭 후 가능

19. 3인칭 시점으로 보기 위해 BP_Player클래스에 camera component 달아줌

20. 키 세팅은 프로젝트 세팅 - 엔진 밑에 입력에서 설정
 - 액션 매핑 : 눌렀다가 떼는거
 - 축 매핑 : 누르고 있는거 (간단한 설명인 듯)

21. 무슨 키를 쓸지 실제로 설정할 땐 검색해서도 가능하지만 키자판 모양 누르고 키보드 입력으로도 설정 가능

22. 키 매핑하고 나면 액터들의 이벤트 그래프에서 블루프린트 배치 가능하게 됨(축 이벤트, 축 값 아님)

23. player controller 클래스의 이벤트 그래프에서 getcontrolledpawn에 대한 키 세팅을 해줘야 함

24. 특정 노드 선택 후 ctrl + w 노드 복제

25. add movement input은 pawn의 멤버함수
 - world 기준 x, y, z축으로 이동이 가능해 보임

26. 만든 player controller는 gamemodebase에 등록해주어야 함

27. 마우스 키 매칭을 하다보니 축 기준으로 회전을 해야 하는데 언리얼 기준으로
 - x축은 롤, y축은 피치, z축은 요
 - 모니터 기준 위아래축 = 요, 좌우 축 = 피치, 들어가거나 나오는 방향 = 롤
 - 요 피치 롤 순서대로 위, 우, 들이라 생각


==========
0308
==========

1. camera를 springarm에 붙임
 - 벽 근처에서 카메라 거리 조정 자동으로 해줌
 - 카메라 위치 초기화, use pawn controll rotation옵션 끄고 붙임

2. 플레이어가 너무 화면 중앙을 차지하는 것을 막기 위해 spring arm의 target offset z값 올려줌

3. controller에서 add movement input이 월드값 기준으로만 움직일 수 있게 되어있었음
 - player의 벡터를 기준으로 해야함
 - get actor forward vector, get actor right vector
 - get controlled pawn에서 얻어옴

4. 애니메이션을 다루기 위한 클래스 따로 있음, 접두어 ABP_
 - 애니메이션 블루프린트 생성
 - 부모 클래스 : animinstance, 스켈레톤 : 엔진 콘텐츠 끄고 남은 1개
 - 이번 프레임에 나갈 애니메이션을 정하기 위한 클래스

5. 애니메이션 클래스가 하는 일은 매 프레임 GetOwner, 즉 캐릭터로부터 velocity(속도)를 얻어와
xy축에 대한 vector length(크기)를 speed 변수에 저장해 줌 
 - Blueprint update animation은 actor의 tick과 비슷한 개념

6. idle, walk, run에 대해서 섞은 애니메이션을 만들기 위해서 <블렌드 스페이스 1D> 클래스를 새로 만들어줌
 - speed 변수를 하나의 축으로 만들어 speed값의 변화에 대해 애니메이션을 섞는 역할

7. BS_Unarmed, 블렌드 스페이스 1D의 옵션에서 Number of grid를 2로 설정해서 상태 3개에 대한 블렌딩 가능

7-1. 만들어진 ABP_, 애니메이션 블루프린트 클래스는 character를 상속받은 player의 animation mode에서 설정을 해주어야 적용됨

8. jump를 설정해주기 위해서 액션 매핑을 해주고 controller에서 이벤트 그래프에서 노드들을 연결해주어야 함
 - 기본적으로 get controlled pawn에서 핀을 끌어다가 어떤 대상에 적용할지를 정해주었는데
 - 언리얼의 기본 상속관계에서 uobject - aactor - pawn - character 순으로 상속이 되기 때문에
 - 우리가 생성한 블루 프린트 클래스가 character를 기반으로 만들었기 때문에
 - pawn이 아닌 character로 down casting을 한번 해주어 jump 함수를 불러주어야 함 (jump는 character의 함수)
 - pressed 중에는 jump이고 released가 되면 stop jumping을 할 수 있게끔 함수가 제공되어 있음

9. 키 입력을 받아 앞, 뒤, 좌, 우로 이동을 해야 할 때 어떤 축을 기준으로 이동을 해야할 지를 생각하면
 - controller의 vector를 기준으로 해야 했고 controller의 forward vector, right vector를 기준으로만 했을 때는 문제가 생김
 - 시점이 위나 아래로 향하게 되었을 때 forward vector가 땅이나 하늘을 향하게 되고 땅을 뚫게 되거나 날 수는 없기에 키 입력이 안 먹게 됨
 - 해결책은 controller의 yaw(Z축)가 얼마나 회전해 있고 그걸 기준으로 forward vector와 right vector를 뽑아내면 문제가 없었음
 - get controll rotation - make rotator - get forward vector순으로 연결
 - make rotator에서 x,y는 0 z축에 controller에서 뽑아온 yaw축을 물려줌

=========
0309
=========

1. controller가 나, <player controller>
 - 클래스 디폴트에서 find camrera component when view target옵션을 켜서 player가 뷰타겟이 됐을 때 카메라 컴포넌트를 찾고
 player camera manager class에서 찾은 camera component를 사용, 이 때 auto manager active camera target 옵션도 체크가 돼 있어야 함

2. Blend Space 1D에서 스켈레톤에 들어오게 되면 캐릭터 - 본 그리기 모든 계층구조를 눌러 뼈대가 어떻게 생긴 지 확인 가능
 - 좌측에 root를 기준으로 상대위치들이 잡혀있음(단순한 transform matrix라고 함)

3. 스켈레톤의 트랜스폼을 조정하는게 애니메이션의 기본 원리

4. 애니메이션에서 빨간 라인을 우측 끝으로 밀어 몇초짜리 애니메이션인지 확인 가능
 - 프레임도 몇개로 이루어져있는지 확인 가능

5. 3D 애니메이션의 기초 : key frame animation
 - 특징적인 몇 지점을 찝어서 그 사이의 이동은 선형보간을 통해 자연스럽게 보이게 함
 - (1-r)x + ry 의 식이 선형 보간 ( 0 <= r <= 1 )
 - Idle, Walk, Run의 애니메이션 조합도 speed값을 기준으로 선형보간 된 것
 - (1 - speed / 300)(Idle) + (speed / 300)(Walk) 이런 식
 - bone과 bone에 대한 선형보간 , animation과 animation에 대한 선형 보간

6. 점프 애니메이션 구현
 - ABP_Characer에의 AnimGraph에서 State machine 만듬
 - state machine을 더블클릭해서 들어오게 되면 entry, 진입점 노드가 있음
 - 이전에 만들어두었던 BS_Unarmed 연결, BS_Unarmed를 기준으로 jump의 시작을 하고 jump가 끝나면 다시 이 상태로 돌아와야 함

7. jump인지를 어떻게 구분하느냐 ?
 - getowner에서 getmovementcomponent를 하고 isfalling을 하면 jump인지 알 수 있음
 - 점프라는 것은 우리가 중력을 이겨내고 올라가는 것이기에 점프를 하는 순간부터 isfalling의 return값은 true(true라는 것은 jump 시작)
 - isfalling의 return값은 이벤트 그래프에서 매 프레임 받아와서 bFalling인 bool변수에 담아둠
 - 이 값을 활용해 점프 중인지 점프가 끝났는지 판단 가능

8. jump시작과 끝은 bFalling변수에 의해 알수 있고 jump_loop는 jump_start의 애니메이션이 얼마나 남았는지를 기준으로 판단
 - time remaining(ratio) - jump_start를 끌어와서 0 ~ 1사이의 값으로 대수 비교

9. 양방향 화살표는 다음 노드를 연결한 선에 있는 표시를 누르고 나면 디테일에서 옵션 조절 가능

10. 이렇게만 하고 나면 jump 중 로켓처럼 탁 튀어오르게 되는데 그 이유는 jump_start랑 jump_end의 animation_loop를 풀어주어야 함
 - state machine에서 애니메이션 클릭 후 ~~재생 탭에서 옵션 설정 가능

11. 캐릭터가 달리던 도중 키를 떼게되면 너무 탁 멈추게 되는데 character의 movement component에 마찰계수 적용하는 옵션 있음
 - general settings에 use separate braking fiction

12. BP_BoxCollision 블프 액터를 만들었고 Box가 root, text를 자식으로 달아줌
 - 이 클래스를 상속시켜 collision이 일어났을 때 다양한 이벤트를 하는 용도, text는 자기 클래스의 이름을 나타내게 됨
 - 기본적으로 월드상에 배치될 때 세팅이 이루어져야 하기 때문에 contruction script에서 세팅을 만져줌

13. text의 위치를 box extent의 z축 위 30으로 잡아주기 위해 set relative location을 통해 text render의 위치를 잡아줌
 - get scaled box extent의 z값에 30을 더해 text의 z location에 달아줌

14. text에 띄울 text를 클래스 본인의 이름으로 하려고 하는데 이 때 C++에서의 키워드 this가 아닌 self 였고
 - getclass -> getdisplayname -> totext(string)을 통해 text에 달아줌
 - string에서 text로 형변환했는데 자료형 차이는 나중에..

15. 과제로 box의 scale에 영향을 받지 않는 text를 구현해야 했음

=======
0310
=======

1. 과제 풀이 중에 get unscaled box extent와 get scaled box extent의 차이는
 - unscaled는 커진 scale이 안 곱해진걸로 ..?

2. 블프 클래스의 뷰포트에서 카메라 리셋 버튼이 있음
 - 카메라 관점이 너무 멀어지면 사용할만 함

3. 월드라이너에서 배치한 액터들에 대해 shift + 클릭 혹은 ctrl + 클릭 등으로 다수 선택 가능
 - 다수 선택 후 트랜스폼에 대해서 일괄 적용 가능

4. 화면에 문자열 출력 하는 함수는 print string이였고 문자열에 대해 append 함수를 사용해 문자열 추가 가능

5. actor overlap과 component overlap의 차이는
 - actor overlap : actor가 가진 어떤 컴포넌트라도 겹쳤을 때 이벤트 발생하고
 - component overlap은 특정 컴포넌트가 닿았다 라는 출력 핀도 뽑아낼 수 있고
 괄호에 해당하는, 즉 component overlap 이벤트를 부르는 component에 대한 겹침이였던 것임

6. cube의 simulate physics 옵션을 키게 되면 중력 적용 및 type object가 바뀜

7. BP_Hit에서 프리셋을 Block All로 바꾸고 Generate Hit event옵션도 켜주었기 때문에 Hit된 actor
가 있으면 Hit event 발생

8. 레벨의 플레이 버튼 옆 화살표에서 현재 카메라 위치에서 시작하는 옵션도 있음

9. object type이 world static이라고 움직이지 못하는 액터가 아님
 - 그저 콜리전 반응을 어떻게 적용할지에 대한 열거형일 뿐임

10. 콜리전 반응과 simulation generates hit events / simulation generates overlap events는
별개로 옵션 만져줘야 함

11. hit은 한쪽만 켜줘있어도 뜨는데 overlap은 양쪽다 켜져있어야 뜸 (event)

12. 프로젝트 세팅 - 콜리전에서 새로운 object type 등록 가능(이름, 콜리전 반응)하고 프리셋도 등록 가능
 - 과제에서 spring arm에 대해 새로운 object type 등록하고 통과시킬 object type 들에 대해선 콜리전 반응을 무시로 바꿨었음

=======
0313
=======

1. 언리얼의 이동은 연속적일 수 없음
 - 게임이라는 것은 결국 프레임단위로 쪼개어 밀리초당 업데이트, 렌더를 하는 것임
 - 상자가 직접 와서 부딪혔을 때 Sweep 옵션이 꺼져있었다면 Hit Event가 발생하지 않았음
 - Sweep 옵션을 켜주게 되면 Hit판정이 나게 되고 상자가 움직여서 캐릭터에 부딪혔을 땐 Hit Event의 Self Moved의 반환값이 True가 됨
 - Sweep이란 빗질을 하는, 이라는 뜻이 있음

2. 캐릭터에 새로운 동작을 주기 위해서 에셋을 새로 추가했는데 이 때 추가하고 나서 BlendSpace1D를 편집하던 과정에서 Animation Sequence들이
편집 목록에 나타나지 않았음
 - Animation Sequence들이 어떤 스켈레톤을 대상으로 하는지에 대한 규칙이 안 정해져 있었기 때문
 - 스켈레톤을 다시 정해주기 위해서 Sequence폴더를 기준으로 필터를 켜주었는데 필터 - Animation - Animation Sequence의 모든 항목을 보고
 - 콘텐츠 브라우저에 나타난 모든 sequence들에 대해 스켈레톤을 재설정해줌 ( 모두 선택 : ctrl + a )

3. 새로운 에셋을 이주하면서 기존에 있던 애니메이션 관련 폴더들을 지웠기 때문에 BP_Player의 MeshComponent에서 Animation Mode에 설정이 깨져있었음
 - 정확히 Animation Mode가 Use Animation Asset이 되어 있었고 이걸 다시 Use Animation Blueprint로 바꾸고 우리가 만든 ABP_Character를 연결해주어야 함

4. 2번에서 필터로 sequence들을 찾았는데 걸었던 필터들을 풀어주려면 필터 누르고 최상단에 필터 리셋 버튼 있었음

5. Roll과 Back Sequence에 대해 montage를 만들어 주었는데 에셋 우클릭 - 생성 - 애님 몽타주 생성 클릭하여 생성 가능
 - montage에 대해서는 montage 폴더 만들어서 따로 관리

6. 몽타주의 노티파이라는 기능이 있는데 몽타주가 진행 중 어느 시점에 대해 알림을 보낼 수 있고 그 알림에 대해 처리를 할 수 있는 기능
 - sequence에도 있는 기능이지만 강화 버전 정도로 생각하면 됨

7. 몽타주는 1회성 동작에 대해 생성한다고 생각하면 됨

8. BP_Character에서 키 입력에 대해 어떤 몽타주를 재생 시켜줄지 함수가 있는데 그쪽에서 어떤 몽타주를 재생시켜줄지에 대한 로직을 짜주고
ABP_Character에서는 그룹 - 슬롯에 맞는 몽타주는 흐름에 맡게 연결시켜주어야 함. 그냥 선형으로 연결해주면 되는거같음
 - 어떤 슬롯인지 찾아서 지정할 때 일단 default sloat을 검색해서 찾아보고 노드에 좌클릭 후 디테일 탭에서 슬롯 변경 가능

9. 몽타주에서 Root의 트랜스폼(위치)에 영향을 주는 옵션이 있는데 몽타주에서 찾을게 아니라 몽타주를 만든 sequence에서 옵션을 찾을 수 있었음
 - Enable Root Motion옵션을 끄게 되면 애니메이션이 Player의 위치를 바꾸지 못하게 됨
 - Capsule Component의 판정 범위를 키고 봤을 떄 enable root motion이 꺼져있었으면 capusle component는 그 자리 그대로 있었음
 - Enable root motion 옵션을 켜게 되면 애니메이션이 재생되는 동안 애니메이션의 데이터가 root에 보내진다 라고 설명하셨음
 - roll sequence에서 캐릭터 - 루트 모션 표시를 켜게 되면 어떻게 진행될지가 보임, 제자리 이동이 아니라

10. 캐릭터 화면 전환 옵션 관련해서는 팁 쪽에 정리해두겠음
 - 입력에 따른 roll, backstep의 방향 정하기가 있었는데 이때 controller가 플레이어의 yaw회전에 영향을 옵션을 켜줬음
(마우스 좌우에 캐릭터 rotation이 영향을 받는 옵션)

=======
0314
=======

1. 입력 방향에 따라 구르거나 백스텝을 밟는 과제를 해결하기 위해
 1-1) GetActorForwardVector 
 1-2) CharacterMovement - GetLastInputVector
 1-3) 이 두 벡터에 대한 내적, 외적을 하는것이 필요했음

2. 애니메이션이 root의 트랜스폼을 결정하는 옵션이 켜져있었기 때문에 에니메이션 자체가 앞뒤로 구르는 모션밖에 없었기 떄문에
애니메이션을 재생하기 전에 액터의 rotation을 돌려주어야 했음
 - 얼마나 rotation을 돌려줄지 정하는 과정에서 MakeRotFromX라는 함수를 사용하여 input 벡터에 대해 rotation을 바로 뽑아낼 수 있었는데
이걸 몰라서 정면, 좌우 판별을 하여 내적, 외적 등 돌아가게 됨

3. GetInputLastVector는 A+W, D+S등 축이 다른 키입력이 2개이면 정규화된 값이 아니였음

4. Dodge를 Space에 액션매핑 해주었고 controller가 조종하고 있는 폰이 dodge를 구현했으면 space바를 눌렀을 때 폰이 구현한 dodge에 따라서
다르게 작동할 수 있게끔 하는게 블프 인터페이스였고 블프 인터페이스를 새로 만들어서 BP_Character에서 인터페이스를 구현해서 1,2에서 했던 노드에
shift 키입력 대신 dodge 이벤트를 이어줌. controller쪽에서는 dodge 액션 매핑에 대해 GetControlledPawn의 Dodge 이벤트가 호출되게 바꿔줌
 - 이렇게 하고나면 BP_Character가 아닌 다른 조종할 pawn에서 인퍼페이스를 상속받고 dodge에 대해서 구현하기만 하면 거기서 구현한 dodge에 대해
space입력 시 다른 동작을 하게 해줌

=======
0315
=======

1. 1교시는 블프 과제 조사한 읽어본 후 인터페이스에 대한 설명
 - 인터페이스는 성격이 다른 두 클래스간에 공통된 기능으로 묶어줄 수 있었고
 - C++의 관점에선 헤더를 줄인다거나 하나의 인터페이스 포인터로 하위 클래스들을 묶어서 기능에 대한 구현이 간편해졌음
 - 인터페이스는 메모리에 특정할 수 있는 공간을 가지지 않는다는 규칙만 지켜주면 기존 인터페이스의 규칙에서 벗어난 변종들이 많음

2. 구현한 인터페이스의 함수에 대해서 같은 함수지만 인터페이스 콜과 함수 호출의 차이는 타깃이 다름
 - 타깃이 다르다는 건 인터페이스로서 호출할 지 클래스 자체로 호출할 지 정도의 차이, 내부와 외부 사용 정도의 차이도 맞는 거 같음

3. 인터페이스 콜은 실패하면 조용히 실패하는 점에서 장점이 될 수 있음

4. BP_Weapon을 만들었는데 SkeletalMesh를 Root로 올려줌, StaticMesh가 아닌 SkeletalMesh인 이유는 무기가 애니메이션을 가지는 경우도 있고
무기에서 파티클의 위치를 정할 때도 용이하기 때문

5. BP_Weapon에서 overlap이벤트 발생 시 ApplyDamage함수에 이어놨음
 - ApplyDamage에서 BaseDamage는 특정할 수 없기에 변수로 승격시켜줬고
 - EventInstigator는 누가 이 데미지를 유발했냐 인데 이게 Player를 핀으로 받을수도 있고 Controller를 핀으로 받을수도 있는데 이 경우는 controller였음
 - DamageCauser : Self

6. BP_Character에서 AnyDamage이벤트로 Damage주는 이벤트에 대한 처리를 해주었는데 BP_Character였던 이유는 Character를 상속해주는 클래스에서
데미지 처리를 하기 위해서 인듯 ?

7. BP_Weapon에서 만든 Damage변수를 자식인 BP_Sword에서 기본값을 10 주었는데 데미지가 0인 경우 이벤트가 발생을 안함 

8. 칼을 장착해주기위해 SK_Mannequin의 스켈레톤 트리를 편집해주었는데 이때 무기를 껴야할 오른손인 hand_r에 소켓을 만들어서 프리뷰 에셋 보기를 통해서 
칼의 위치를 잘 잡아줌
 - 프리뷰 에셋 보기는 우리가 만든 BP_Sword의 클래스가 아니라 그저 에셋을 보기 때문에 아까 Mesh가 root였던 이유가 그 이유임
 - 기껏 위치 잡아놨는데 mesh가 다른 root에 대해 상대적인 위치라면 프리뷰 한것과 다른 위치에 스폰됨

=======
0316
=======

1. 무기가 overlap되면 ApplyDamage를 일으키면 그 이벤트를 BP_Character쪽에서 AnyDamage로서 받고 있는데 이떄 주인에 대한 처리가 안되어있기에 자해를 하는
무기가 됨
 - Instigator이면 데미지를 안 주는 식으로 처리함
 - owner를 쓰면 안되는 이유는 무기의 owner가 instigator가 아닐수도 있기 떄문(활집의 주인이 활인 경우 정도 ?)

2. BP_Character에서 BP_Weapon에 대해서 Bp_Weapon의 클래스들에 대해서 SpawnActor를 하게 되는데 이때 BP_Weapon 클래스들에 대해 배열에 담아 놓고 
for each loop를 통해 담아 놓은 모든 클래스들에 대해 spawn 시켜줌
 - 옵션에 대한 부가 설명이 좀 많았는데
 - spawn transform을 지정해주지 않으면 에러가 났고 지정할 수 있는 2가지 방법은 1)핀분할 2)MakeTransform
 - weapon의 owner는 self(character 자신)
 - collision handle override 옵션은 default로 잡혀있는데 이 옵션이 뭐냐면
  - 액터가 월드에 없다가 생기는 것이기 때문에 그 위치에 다른 액터가 있을 수 있음
  - 이 때 처리를 어떻게 해줄지를 정해주는 것인데 actor의 클래스 디폴트 탭에서 기본값 설정해줄 수 있었음
 - Instigagtor는 따로 설정해주지 않으면 owner로 설정된다고 함

3. BP_Player에 와서 손에 붙여 보기 위해 일단 클래스 세팅에서 weapons 배열에 BP_Sword를 0번 인덱스에 넣어주었고
이 0번에 넣어놓은 무기를 hand_r 소켓에 넣어주려고 하는데 이 때 AttachActorToComponent 함수를 사용함
옵션이 많았는데
 - 타깃 : 무기 자신
 - parent : 함수 이름에서 알 수 있듯이 무기(actor)를 socket이 있는 오른손, 즉 스켈레탈메시를 가지고 있는 mesh(component)였음, 즉 mesh를 달아줌
 - transform에 대해 rule을 정할 수 있는데 socket의 transform과 actor의 transform 둘중 어떤걸 쓸지 혹은 둘을 곱해서 쓸지 정도의 옵션임
   - keep relative : socket * actor
  - keep world : actor
  - Snap to Target : socket

4. 칼을 꺼내는 모션을 달아주기 위해 Draw_1, Draw_2의 애니메이션 시퀀스를 사용해야 했는데 칼을 달고 나니깐 칼이 등을 파고드는 등 애니메이션을 조금 수정해야 했음
 - 이처럼 맞지 않는 애니메이션이랑 무기 조합이 있을 수 있는데 이럴 때 밑에서 말할 작업을 해줘야 함
 - 보통 맞는 걸 찾아쓰게 된다고 함..

5. 수정해줘야 하는 애니메이션의 본을 찾고 애니메이션의 몇 프레임부터 수정을 해줘야 하는지를 정하고 그때의 transform을 바꿔주는 작업인데
 - Draw_1의 경우 upperarm_r, lowerarm_r, hand_r에 대해 바꿔주어야 했고 각 본은 클릭한 뒤 에디터 상단에 키[key]를 눌러주어 에디티브 레이어 트랙을 만들어 줌
 - 만들어진 에디티브 레이어 트랙을 수정하는 작업인데
 - 원하는 프레임에 가서 수정헤야 할 본에 대해 transform을 바꾸고 키[key]를 누르게 되면 그래프가 바뀜으로서 수정이 이루어진 것이고 이 작업의 반복을 해야 함

6. 애니메이션이란 구분동작을 선형보간하여 만드는 것이 기본인데 이렇게 만들어진 구분동작에 대해 추가적인 동작을 주는 작업이 에디티브 레이어 트랙이였음

7. 칼을 뽑는 애니메이션을 자연스럽게 만들어주었고 그렇다면 칼을 뽑을 위치를 정해주어야 하는데
 - 어떤 본에 소켓을 달아줄까 했을 때 ? 
 - 만약 목에 달게 되면 목이 아래를 향하게 되면 칼은 목의 transform을 따라 바닥을 수직이닥 바닥과 수평이 될 것임
 - 따라서 움직임이 적을 spine_03을 골라주었음

8. spine_03에 소켓을 만들고 프리뷰 에셋을 하여 칼의 위치를 잡아주었는데
 - 칼을 딱 쥐어야 하는 시점에 맞는 Draw_01의 지점을 찾고 그 위치랑 겹치게 세팅해주면 되었음

9. 등에 붙어있던 칼을 Draw_1이 끝나는 시점에서 손으로 옮겨붙여 주어야 했는데
 - 이 때 Draw_1의 애니메이션에서 노티파이 이벤트를 발생시켜서 ABP_Character에서 손으로 옮겨붙여주는 작업을 해야하는데
 - 안 좋은 방법의 예시를 일단 설명해주었고 그 이유를 찾는게 과제였음
 - 추정한 이유로는 무기를 꺼내는 모션에 대해 무기가 꺼내져있는지에 대한 체크가 없이 손에 붙는 처리 방식이 문제였다고 생각했음

=======
0317
=======

1. 칼 꺼내는 동작을 구현한 그래프에서 문제점을 찾아보는 것이 과제였었는데 그 중 문제로 제기됐던 것 중 하나로 칼을 꺼낸 후 구르고 나면 칼을 꺼내는 모션이 다시
동작하는 것이였음
 - 이것의 이유는 몽타주가 재생하고 나면 스테이트 머신의 entry부터 다시 진행하게 되기 때문인데
 - 간단하게 해결할 수 있는 방법은 몽타주의 옵션중에 Always update source pose 옵션을 체크해주면 해결되었음
 - 저 옵션의 위치는 anim graph 에서 슬롯에 왼클릭 후 디테일 탭에서 설정 가능

2. 검을 뽑으면서 움직여지는 것도 문제 중에 하나였는데 간단한 해결법은 root motion을 켜주는 것이었음
 - Draw1, Draw2의 enable root motion을 켜주고 ABP_Character의 클래스 디폴트에서 root motion 관련 옵션중에 몽타주뿐만 아니라 전부에 적용할 수 있는데
이 옵션을 켜게 되면 해결은 가능하나 이 방법은 아님

3. 블프에서 디버깅하는 방법에 대해서도 나왔는데
 - 블프 디버깅은 인스턴스에 대한 디버깅으로 플레이 중에 특정 인스턴스에 대한 중단점을 걸어서 확인해 볼 수 있음

4. 노티파이 관련해서도 스켈레톤에 노티파이 추가를 하게 되면 특정 본에만 적용되는 노티파이가 되는 것이기 때문에 확장성이 떨어짐 (문제 1)
 - 여러 스켈레톤에 대해 같은 동작을 정의하고 싶으면 이 방법은 지양해야 함

5. BP_Character에 형변환해서 사용하는 이런 방법은 확장성이 떨어짐, 유지보수 불리 (문제 2)

6. 문자열에 의존하는 것은 지양해야 하는데 문자열에 대해 변수로서 관리하는 방법을 항상 고민해 봐야 함
 - socket에 대해 이걸 적용해본다면 GetOwningComponent - GetAllSocketNames 를 얻어와서 처리하는 방법이 가능하긴 하나 
 - socket의 경우 그냥 조심해서 사용해야 하는 것 같음

7. 형변환은 언리얼 기본 제공 클래스에 대해서만 꼭 필요할 때 하는 것을 추천하고 키입력 이벤트는 테스트용으로만 사용해보고 앵간하면 controller 쪽에서 처리해야 함

8. 결국 언리얼 포폴이란 것은 1) 블프로 한다면 나 블프 다룰 줄 안다는 것을 알려주는 것이고 2) 구조설계를 잘했다를 어필하면 좋을 수 있음

9. AnimGraph에서 들어오거나 나갈 때 블레딩될때의 이벤트를 각각 이름 지어주어서 다른 클래스의 이벤트그래프에서 사용할 수 있었고
이것은 트랜지션에 대해서도 마찬가지(트랜지션 : 애니메이션이 변하는 조건 정의해준 곳)
 - 몽타주가 아닌 애니메이션 시퀀스 혹은 상태머신에 들어와서 애니메이션 시퀀스에 대해서 이 옵션 조절 가능
 - 상태머신에서 트랜지션 룰에 대해서도 마찬가지로 이벤트 생성 가능
 - 애니메이션 간에 블렌딩에 관해서도 옵션이 있음, 시간 몇초 부터 섞을지 ?

10. 블프 그래프 정리하는 것에 대해선 전체 드래그 한 다음 q 누르면 자동으로 정리 되고
 - shift + wsad 로 정렬하는 것 정도 있음

11. 에디터 개인설정에서 새 창 뜨는 것들에 대해 main window에 붙이는 것에 대한 옵션이 있었고
 - 일반 - 외형 - 에셋 에디터 실행 위치 에서 조절 가능
 - 에디터 개인설정에서 블프 그래프 움직이는 모션 스무스하게 바꿀 수 있고 (그리드 크기?)
 - 뒤 모눈 없애는 설정도 있었음

12. 기존 방식은 월드에서 위치 상관없이 스폰한 후 bone_spine_03에 다시 붙여주는 방식이였다면
 - 무기가 캐릭터의 어디 붙어야 할지에 대한 정보를 가지고 이 정보를 만들자마자 해주는 처리를 한다한 거 같음

13. 위에서 언급한 특정 클래스로 형변환 하는 것은 문제가 되기 때문에 WeaponA, WeaponB를 드는 동작에 대해 액션매핑을 해주었고
그 동작에 대해 인터페이스도 만들어주었음
 - 무기드는 동작에 대해 액션매핑한 이벤트를 호출할 때 단지 인터페이스로 정의한 함수를 부르기만 하면 됨
 - 인터페이스를 상속받은 클래스에서 다르게 처리해야 할 동작이 있다면 거기서 처리

14. 입력에 대해서(아마도 프로젝트 세팅에서 매핑해놓은 키 입력 이벤트에 대한 것만 해당하는 듯) 상위의 존재가 입력을 소모해버리면 밑에서는 입력을 못 받게 되는 구조를 띄는데 그 순서는
 - 1) input enabled actor 2) controller 3) level blue print 4) pawn 순인데
 - 위에서 입력 이벤트를 처리했어도 입력을 소모시키지 않는 옵션이 있는데 어딨냐면
 - 축매핑을 사용하겠다고 이벤트에 배치한 곳에서 좌클릭 후 디테일 탭에서 확인 가능, consume input 옵션

15. 입력에 대해서 위에서 설명한 4개 구조에 대해서 하위로 아예 input을 안 줘버리겠다는 식으로 쓰고 싶으면 예를 들어 player controller 밑으로 못 쓰게 하려면
 - controller쪽의 클래스 디폴트에 입력 관련 옵션에 block input 옵션이 있음
 - 최종은 이렇게 쓰는 것이 좋아보이고 작업하는 과정에선 테스트 input을 받아 봐야 하기 때문에 옵션 풀어줌

16. BP_Character에서 인터페이스에 대해 상속 받고 WeaponA, WeaponB에 대해서 구현해주는데,,
 - 이벤트에선 지역변수 선언이 불가능한데 이것에 대해서 꼼수? 처럼 쓰는 방법이 있음
 - 지역변수 관련해서 make float, make int 등과 설명해준다 했음

17. 16번에서 말한 꼼수는 Uobject에 대해서 매크로 라이브러리를 하나 새로 만들고 매크로를 하나 새로 만들어서 출력 핀을 와일드 카드로 주는 방법이였음
 - 아마 와일드카드가 어떤 변수로든 변환해서 사용가능하고 이걸 이벤트의 로컬처럼 쓰는 것 같음

18. 매크로를 만들 때 계층을 설정해주는 이유는 character의 고유한 함수인 jump를 예를 들면 이 함수가 uobject 밑에서 매크로로 되어 있으면 문제가 생긴다는 것임
 - character가 아닌 데서 치환되는 식으로 그 함수가 들어가면 문제