======
0403
======
	1. 스킬을 구현하기 위해서 무기에서 했던 것과 같이 character의 beginplay에서 spawnactorfromclasses로 생성하여 가지고 있음
	- 클래스를 담는 배열과 래퍼런스를 담는 배열 구분
	- CurrentSkill 단일 변수를 만들어서 현재 스킬에 대한 것도 관리

	2. 위 작업을 constructionscript가 아닌 beginplay에서 하는 차이점에 대한 질문이 있었는데
	- 일단 첫번째로 저 작업을 beginplay에서 한 이유는 spawnactorfromclasses가 constructionscript에서는 부를 수 없음
	- constructionscript의 주 용도는 이 클래스를 월드에 배치 한 순간 동작하는 것이고
	- 인스턴스별로 뭔가 변화가 생겼을 때도 constructionscript를 실행해주는데
	- 이걸 응용하게 되면 bool변수나 enum변수로 어떤 변수를 주는지에 따라 어떤 component를 가질지를 인스턴스를 월드에 배치한 이후
	정할 수 있음
	- 하지만 또 한계라 한다면 AddComponentByClass같은 함수 사용은 제한되어서 명시적으로 변수의 어떤 값엔 어떤 컴포넌트를 추가하겠다 같은 식의
	선언을 해야 함
	- beginplay나 constructionscript나 생성자나 시작할 때 처리하는 것은 같지만 3개는 미묘하게 다른 부분이 있으니 일단 인지하고 넘어감
	- 추가로 변수 값 변화에 따라서 추가되는 component를 확인해 볼 때 에디터 개인설정 - 콘텐츠 에디터 - 블루프린트 에디터 - 디테일 보기에서 컨스트럭션 스크립트
	숨김 에 대해서 체크를 풀어주고 사용해야 변화된 component확인 가능(default는 constructionscript 숨김)

	3. sequence에서 이미 연결했던 핀을 다른 곳으로 옮겨주는 거 ctrl 누르고 핀 클릭 후 드래그하여 가능(sequence만은 아니고 모든 연결 선에 대해)

	4. 역할별로 comment 박스 만들어줌

	5. skill A,B,C 액션매핑 만들고(z,x,c) 컨트롤러에서 character에 상속한 skillA,B,C인터페이스 콜해줌
	- chracter쪽에서 상속받은 인터페이스 구현만 하면 skillA,B,C에 관한 키 입력 시 호출됨

	6. 키 입력을 길게 누르다가 떼야 작동하는 이벤트에 대해서 2가지 방법 정도 생각해 볼 수 있는데
	- 인터페이스에서 pressed랑 released에 대해 2가지 함수를 만들어서 각각 동작시켜주는 것이랑
	- 인터페이스쪽 함수에서 하나만 만드는데 대신 input값으로 bool변수 하나 받아서 filpflop으로 처리해주는 방법(키 이벤트의 pressed랑 released는 둘다 flipflop
	으로 들어오는 흐름, 누르면 true, 떼면 false 이런 식으로)

	7. Delay와 RetriggableDelay의 차이가 있는데
	- Delay는 Delay중에 다른 Delay가 들어오면 무시하고 본인의 남은 시간을 끝내기만 하는데
	- RetriggableDelay는 Delay중에 다른 RetriggableDelay가 들어오면 다시 그 시점부터 Delay 시작함
	- 적의 피격 색이랑 타격 시 경직에 대해 Delay -> RetriggableDelay로 바꿈

	8. Sequence와 Gate를 활용하여 이단입력에 대해서만 작동하도록 만들 수도 있는데
	- 키 이벤트 - Sequence - Gate 순으로 배치하고
	- Sequence의 Then0는 일단 실행쪽으로 들어가고(Gate가 처음엔 막혀있음)
	- Then1이 Open의 흐름에 들어가서 문을 열어주고
	- Then2는 delay0.25초 뒤에 Gate 문을 다시 닫음

	- 핵심은 Then1과 Then2 사이에서 새로운 키 입력에 대해서 Gate가 열려있기 때문에 Gate를 통과할 수 있게 됨

	9. IsValid로 변수에 대해 null체크를 할 수 있었는데 (혹은 class에 대해 null체크가 가능한 함수도 있음 IsValidClass였나?)
	- 변수 getter에 우클릭해서 변수의 유효성 검사를 통해 IsValid와 같은 일을 할 수 있음

======
0405
======
	1. 스킬 장착부분을 구현하는 것이 과제였음
	- weaponA,B를 장착하는 것과 비슷한 로직
	- getter에 유효성 검사를 해서 CurrentSkill에 유효성 검사를 적용하면 스킬 장착 여부를 알 수 있었고
	- 장착하지 않았다면 장착해주면 되고
	- 장착한 상태라면 지금 누른 스킬과 장착한 스킬이 같은지 아닌지를 검사해서 추가적인 처리를 해줌

	2. 정씨 과제중에 getter의 유효성 검사하는 노드에 대해서 호출 시점인지 아니면 cache된 내용일지에 대해 논란이 있었는데
	- 결론은 호출 시점에서 getter를 다시 돌리는 식임(본질이 getter이기 때문, 실행핀이 있지만)

	3. 게임에서 안 보이게 하는 방법 중에
	- CurrentWeapon - SkeletalMesh - SetVisibility보다
	- CurrentWeapon - ActorHiddenInGame 핀이 더 낫다고 하는데
	- 그 이유는 액터가 가지고 있는 딱 어느 대상을 집어서 동작시키는 코드는 피하는 게 좋다고 함

	4. 스킬이 장착되어 있지 않을 때만 무기 장착이 가능해야 하기 때문에
	- WeaponA,B쪽에서 진입 근처에 CurrentWeapon이 유효하지 않을때만 들어갈 수 있게 바꿈
	- 아마 공격도 마찬가지(Action)

	5. IsArmed같이 무기 장착 중인지 확인하기 위해 만들어놓은 함수 혹은 인터페이스가 있다면 이것을 쓰는 것이 맞음
	- CurrentWeapon을 검증된 get으로 변환해서도 같은 작업이 동일하지만 이렇게 IsArmed를 써야 하는 이유는
	- 코드의 가독성도 그렇고 IsArmed가 변화했을 때 일괄 처리되어야 하기 때문임

	6. BS_Caster 블렌드 스페이스를 만들어줌
	- Wizard_Idle, WizardWalk 4방향, WizardRun 4방향 적용해줌(Speed, Direction)

	7. ABP_Character의 이벤트 그래프 중에 수정해 준 부분이 있는데
	- ABP_Character가 Armed 변수를 가지고 있었고 그 변수를 매 tick마다 업데이트를 해주는 방식이였는데
	- 그 방법이 IsArmed 인터페이스를 콜해서 얻어오는 식이였음
	- 그것이 아니라 캐릭터가 무기를 장착하는 과정에서 ABP_Character의 변수를 업데이트하는 ABP의 인터페이스를 콜해주는 것이 맞는 방식
	- 하지만 기존 ABP의 bArmed로 스테이트 머신을 제어하는 방법은 안 쓰기로 했기 때문에 기존 bArmed 부분은 다 지워줌

	8. bArmed를 지웠기 때문에 캐릭터가 무장상태인지 비무장상태인지 알 방법이 없어짐
	- WeaponType 열거형을 추가하고(일단 None과 Sword를 가짐)
	- ABP전용 인터페이스를 만들어서
	- WeaponType을 input으로 받는 인터페이스 함수 정의해줌, 추가로 skill의 activate를 제어하는 input이 bool인 인터페이스 함수도 하나더 정의함
	- 무기의 최상위인 BP_Weapon이 아니라 상속받은 BP_Sword쪽에서 WeaponType값 지정해주고(Sword) BP_Weapon에선 이 type을 블프읽기전용으로 처리(야메임)

	- WeaponA,B 쪽 로직 끝 부분에 가서 ABP의 WeaponType변수를 바꾸는 로직 추가
	- ABP의 WeaponType으로 블레드 포즈 하는 노드가 있음

	9. ABP쪽에서 기존 Idle과 Sword상태를 전환하는 스테이트 머신을 지우고 
	- BlendPose(E_WeaponType)노드를 추가하고 (ABP가 가지고 있는 WeaponType변수가 무엇인지에 따라 애니메이션 결정함)
	- BlendSpace3개(Unarmed, Sword, Wizard)3개를 놓고
	- 각각 입력 핀에 변수를 연결해줘야 하는데 더 좋은 방법은
	- 노드 클릭 후 디테일 탭에서 핀에서 바로 X,Y값에 어떤 변수쓸지 할당해 줄 수 있었음

	- BlendPose 기본 포즈에 Unarmed주고 E_WeaponType이 Sword이면 BS_Sword포즈로 바뀌게끔 하고
	- Wizard포즈는 Sword에서도 갈 수 있고 Unarmed에서도 갈 수 있는 포즈이기 떄문에 bool로 블렌드 포즈하는 노드를 새로 만들어서
	- bSkillActivated변수로 제어함

	- 결론적으로 ABP가 가지고 있는 E_WeaponType으로 어떤 포즈 취할 지 먼저 정하고
	- bSkillActivated 변수가 켜져 있으면 BS_Wizard를 우선하는 방식으로 처리하는 것

	- BlendPose(E_WeaponType)에서 새로운 E_WeaponTyep이 생겨서 새로운 무기에 Type을 다르게 주면 새로운 BlendSpace를 넘겨서 다를 포즈를 취할 수 있게 됨

=======
0405
=======
	1. 스킬의 장착과 동작 전환까지 처리가 되었음
	- 스킬을 든 상태에서 action을 하면 칼 휘두르는 모션이 나감(weapon을 들다가 스킬을 꺼낸 경우)

	2. BP_Teleport를 구현하기 위해 Teleport의 tick에서는 매 프레임 커서가 가 있는 방향의 위치 정보와 그 위치의 법선벡터를 받아와서
	처리하게 되는데
	- 커서의 위치와 법선벡터를 구하는 함수 GetDestinationData를 만들었고
	이 함수는 GetHitResultUnderCursorForObjects에서 필요한 정보만 뽑아 낸 함수
	- 원래 이 처리를 하기에 적합한 함수는 아니나 소개할 기회가 없을 것 같아서 소개했다고 함(롤, 스타의 이동 같은 거 처리가 더 적합한 함수)
	- 적합한 함수는 LineTracing
	- cursor가 worldstatic에 대해서만 hit할 수 있도록 함수 배열에 넣어줌

	3. Tick마다 GetDestinationData를 활용해 cursor위치에 hit된게 있으면 그 위치에 Decal을 찍어주도록 만듬(visibilityOn, setlocation(decal))
	- 법선벡터를 활용해 decal의 rotation을 바꿈(decal의 전방을 hit된 곳의 법선벡터로 만들어줌, MakeRotFromX)

	4. 스킬을 들게 되면 무기를 든것과 동일하게 OrientRotationToMovement 옵션 건들여줌

	5. getter를 아끼지 마라
	- 가독성이 더 나음

	6. 마우스 좌클릭으로 무기를 통한 공격이나 스킬 공격을 둘 다 처리하는데
	- 스킬 공격을 우선 처리하도록
	- 무기를 든 상태에서 스킬을 활성화하면 IsArmed이기도 하고 스킬도 있지만 스킬을 우선 발동하도록 처리함
	- ActionA쪽에서 스킬쪽과 무기쪽으로 분기가 나뉨

	7. BP_Skill쪽에 BeginAction, EndAction이라는 커스텀 이벤트 만들고
	- Action쪽에서 스킬 발동하면 불러주는 식으로

	8. 스킬 발동은 스킬 시전하는 모션이 나오기 전에 BeginAction이 콜 되고 스킬에 만들어놓은 노티파이에 대해 EndAction을 부르는 식으로 만듬

	9. BP_Skill쪽에서 GetMontageData 기본 형태만 만들고 BP_Teleport에서 Teleport하는 몽타주를 연결해주기만 하면 되는데
	- Wizard_Spell_Montage를 실행하게 만들어주고
	- 시퀀스에서 몽타주를 만들 떄 만들고나서 슬롯설정을 필수 spell은 fullbody

	10. Teleport의 BeginAction에서 처리하는 내용은 Destination이 유효한지에 대해 bool에 저장하고 실제 이동위치를 그 위치의 수직 150 위로 Destination변수에 설정

	11. EndAction에서는 Emitter를 발생시키고 실제 캐릭터의 SetActorLocation으로 설정해 줌

	12. 이미터는 도착지랑 출발지에 둘다 설치하기로 함
	
	13. 이미터 눈뽕이 오져서 이미터를 살짝 바꿔줬는데
	- 스케일을 .5로 줄이고 이미터 자체의 눈뽕 효과를 꺼줌
	- 아쉽게도 파티클(이미터)은 머티리얼 인스턴스처럼 상속해서 개별로 뻗어나가는 식의 처리는 불가능
	- 복사해서 이름 바꿔서 사용해야 하는 듯

=======
0406
=======
	1. 텔레포트 만들고 나서 마지막 수정은 일정거리 이상일 때 데칼이 안 보이는 것인데 
	- Decal의 FadeScreenSize를 0으로 바꿔줌(default 0.01)
	- 화면의 몇 퍼센트 밑으로 크기가 작아지면 화면에서 안 보이게 하는 옵션(default 1%)

	2. 새로운 스킬 FireStrom을 만들어보자
	- BP_Skill 상속받고
	- ParticleSystem 추가하고
	- ParticleSystem의 AutoActivate끄고
	- collision 추가해주고 크기 맞춰주고(z위치300 캡슐크기 높이 : 500, 반지름 : 200)
	- 캡슐의 overlapevents 꺼주고

	3. 다단히트로 구현하기 위해
	- beginoverlap되면 배열에 넣고 endoverlap되면 배열에서 빼고
	- 배열에 들어있는 애들에 대해 0.몇초마다 데미지를 넣는 방식

	4. 주변을 도는 화염 기둥을 구현하기 위해 스킬 발동하면 캐릭터의 전방 vector를 기준 벡터로 잡고 각도를 0으로 초기화해줌(EndAction, 몽타주의 노티파이)
	- particle은 activate해주고 capsule의 overlap은 켜줌

	5. 오버라이드 가능한 이벤트들은 왼쪽탭에서 우클릭 후 함수로 변환 가능(local변수가 필요하다면? 써볼만한)

	6. tick에서는 particle이 active라면 불기둥이 돌아가는 처리를 해주어야 하는데 2가지 방법이 있음
	- 어려운 방법은 삼각함수의 cos, sin을 이옹해서 actor위치 기준으로 각을 계산해서 setactorlocation 해주는 것

	7. tick에서 각도에 대해 +1 씩 해주는 방법은 문제가 있음
	- 컴퓨터 사양에 따라 tick호출 횟수가 달라서 사양이 좋으면 스킬이 빠르고 안좋은면 느려짐
	- AngularSpeed * DeltaSeconds를 Angle에 tick마다 더해주면 사양에 상관없는 같은 결과를 얻을 수 있음

	8. 0.125초마다 배열의 담긴 액터들한테(불기둥안에 들어온) 데미지를 주기 위해 간단한 구현은
	- Tick에서 Delay로 처리하는게 간단한 방법(Retriggable은 여기서 쓰면 안됨)
	- Deligate를 써서 해결해보자

	9. SetTimerByEvent로 CustomEvent(DamageEvent만들어서 할당해주고 .125초마다 발동하게 끔 처리
	- CustomEvent(DamageEvent에 대해 처리해주는 것

	10. 5초 뒤에 스킬을 꺼주기 위해
	- SetTimerByEvent에서 Event핀에 EventDispatcher에서 생성해서 스킬을 끄는 함수를 물려줌(OnTimeOver)
	- 함수를 이벤트로서 timer에 바인딩해주는 느낌
	- OnTimeOver는 particle을 deactivate하고 capsule의 overlapevents를 꺼주는 함수

======
0407
======
	1. SetTimerByEvent의 실햄흐름은 다른 흐름이라고 봐야 함
	- 세팅된 시간만큼 바인딩 된 이벤트의 흐름을 실햄 함
	- 타이머 설정을 해주었으면 필요하지 않을 때 꺼야하는데
	- pause하는 방법이 있고 timer를 비웠다가 다시 세팅하는 식의 방법이 있음
	- 걸어준 이벤트에 함수를 거는 방법이 있는데 이벤트 생성 노드를 만들어서 함수를 걸어주었음
	- 근데 이벤트 디스패처가 함수를 커스텀 이벤트로 만드는 것이냐고 했을 땐 아닌 것이
	- 이벤트 디스패처의 본질은 함수 포인터인 것이고 단지 걸어준 함수를 이벤트로서 사용할 수 있던 것

	- pause, unpause는 unpause 당시 시간이 남아있기 때문에 부정확할 수 있음
	- 그런 오차가 허용 안되는 상황이면 타이머를 비우는 방식을 채택해야 함
	
	2. 위에서 사용했던 이벤트 생성은 싱글캐스트 델리게이트 인것 같음
	- 이유는 변수로 만들 수 있는 이벤트 디스패처는 기본값이 멀티캐스트 델리게이트이며 편집이 불가능한데
	- 이걸 만들어서 SetTimerByEvent에 걸어주고 싶었는데 실패했음
	- 그리고 이벤트 생성 노드도 핀추가라던가 더 걸어줄 함수를 추가하는 핀이 없었음

	- 이벤트 디스패처에 여러 이벤트를 걸었다면 그 디스패처를 호출해서 실행흐름이 있는 핀으로서 연겨해주면 되는데
	- 이게 SetTimer노드의 이벤트에 바인딩 되려면 디스패처를 커스텀이벤트로서 다시 만들어서 거기서 호출 노드를 흐름으로 연결해주면 됨

	- 이벤트 디스패처에는 input인자들이 같고 output은 없어야 함
	- 멀티캐스트에서는 기본적으로 반환값을 활용을 못하는데 블프에서는 반환값이 있으면 그 자체로도 멀티캐스트 델리게이트에 걸어줄 수 없었고
	- C++에서는 반환값이 있어도 걸어줄 순 있으나 반환값의 활용은 힘든 것으로 보임

	3. 멀티캐스트 델리게이트는 옵저버 패턴에 활용하기에 좋음
	- 업적 시스템같은
	- 기본적으로는 인터페이스가 더 강력하기 때문에 인터페이스를 적극 활용하는 것이 좋음(커플링 면에서도 인터페이스가 약한 커플링)

	4. EndOverlap에서 OverlappedActors배열을 비워주는 것과 별개로 스킬이 끝나는 시점에서도 비워줘야 함
	- 버그가 발생할 수 있음
	- 아마 겹쳐있는 시점에서 EndOverlap이 호출되지 않고 스킬이 꺼지면 그럴 수 있다는 것 같음

	5. overlappedactor가 배열인 이유는 결국 특정 원소를 꺼내야 처리할 수 있는 내용이 있기 때문
	- overlap이 끝나면 특정 액터를 배열에서 비워주는 식의 작업이 이에 해당
	- set이였다면 결국 배열로 바꿔서 처리해야 하기 때문에 2번 일하는 꼴

	6. 블프의 배열은 읽기 전용으로 걸어도 값이 변경 가능함
	- 이런 빈틈이 있는 이유는 ADD, REMOVE같은 함수가 Library에서 불러 쓰는 것이기 때문
	- Set같은 경우는 막을 수 있음(다른 배열을 통째로 덮어 쓰는 경우)

	7. RotateVectorAroundAxis가 있는데 우리 수업은 고정 값 정면 벡터에 대해 angle값만 변경시켜주어서 스킬의 location을 정해주는 방식
	- 아마 중요한 점은 angle이 변하는 값이고 벡터는 고정값이어야 함
	- 축은 z축을 기준으로 주었는데 getactorforwardvector라던가 다양한 vector를 넘겨주어서 다양한 표현이 가능

	8. 결국 파이어스톰이 캐릭터 주위를 돌수 있는 것은
	- 월드상의 원점을 기준으로 어떤 방향을 가질 지 벡터를 정해놓고 그 벡터에 얼마만큼 멀어질지 상수값을 곱해서
	- 내 캐릭터의 위치에 그 벡터를 틱마다 더해주어야 가능

	9. 새로운 스킬 파이어볼을 만들기 위해 스킬이 activate된 시점에 몸 주변에 불타는 오라를 켜줬는데 꺼질 때 반응이 늦어보임
	- 파티클 자체에 꺼질 때 딜레이를 얼마나 줄지에 대한 옵션이 있긴 한데 잘 적용이 안된다고 함
	- 바로 꺼지길 원한다면 visible을 건드리면 된다고 함
	- 이거 관련해서 파티클의 원본에 가서 특정 이미터에 적용된 lifetime에서 값을 수정해주면 되긴 함

	- 추가로 파티클 관련해서 따로 만져봤는데 캐스케이드(파티클 편집기) 내에 커브에디터에 특정 이미터에 소속된 특정 이미터를 올려주면 값 그래프로서 편집이 가능함
	- 이미터에 걸려있는 머티리얼에 대해 dynamic으로 바꾸고 값을 바꿔주는 식으로 해봤는데 이미터가 그 머티리얼에 색을 덧씌운다던가 하는 방식으로
	작동하기에 적용이 안 되었었음
	- 현재로선 파티클을 내 입맛대로 다루려면 케스케이드에서 내가 직접 편집하는 수밖에 없는 듯
	- 개인적으로는 파티클의 전체 visibility를 꺼버리기 보단 파티클을 직접 편집하는 게 연출 상 더 좋아보이는데
	- 큰 덩어리는 빠르게 꺼주고 잔상은 남기는 식으로 편집하면 좋을 듯

	10. ABP에서 본마다 레이어로 블렌딩 노드에서 MeshSpaceRotationBlending 옵션이 있었는데 이걸 체크해주어야 Wizard_Attack 몽타주가 제대로 동작
	- 로컬 스페이스는 spine_01을 기준으로 하체에 대해서 원래 애니메이션이 회전이 없기 때문에 회전을 안 시킨 듯
	- 하지만 wizard_idle포즈와 wizard_attack포즈가 각각 개별로 동작했을 때 이걸 블렌딩 하면 실제로는 attack시 하체는 그대로고 상체가 돌아야 함
	- 메시 스페이스에서의 회전을 적용시켜줘서 하체와 상체가 기존의 애니메이션과는 다르게 돌릴 수 있었음

	11. 캐릭터에 적용된 스켈레탈 메시는 -90도 돌리고 z위치를 -90 내려서 적용해주었는데
	- 이렇게 되면 기존의 스켈레탈 메시랑 비교해서 정면 축이 바뀐 것이고 이것이 본마다 레이어로 블렌딩 노드에서 문제가 생기게 된 이유임
	
	12. 로컬 스페이스에서 블렌딩을 하게 되면 그 공간에서 attack 애니메이션은 하체에 연결 되어서 하체의 rotation에 영향을 받은 애니메이션인거고
	메시 스페이스는 하체에 영향을 받았더라도 최종적으로 하체가 영향을 준 상체를 블렌딩하겠다는 뜻

	13. 이렇게까지 하고 나면 상체가 너무 도는 문제가 있었는데 상체 부분에 블렌딩 된 애니메이션에 대해 뼈마다 얼마나 적용할지 정해주는 BlendDepth옵션이 있었음
	- 설정한 뼈를 기준으로 BlendDepth가 4라면 설정한 뼈는 1/4의 블렌드를 그 뼈 바로 위의 자식은 1/3, 그 위는 1/2, 1/1, 1/1, 1/1...되는 옵션임
	- 그래서 Depth가 높아지면 설정한 뼈 근처에서는 블렌딩 된 애니메이션이 적게 나오기 때문에 허리가 덜 돌아가 보이는 것

	14. 지금 설정한 뼈가 0번의 0번 인덱스인데 0번의 1번 0번의 2번 이런 식으로 블렌딩하기 위해 들어오는 애니메이션에 옵션을 더 달아 줄 수 있고
	- 만약에 노드 자체에 핀을 추가해서 1번 애니메이션 2번 애니메이션을 추가로 블렌딩 할떄는 1번의 0번, 1번의 1번, 2번의 0번, 2번의 1번 이런 식으로
	몇 번째 애니메이션의 뼈에 얼마만큼의 뎁스를 줄지를 각각 정해 줄 수 있음
	- 우리가 한 건 0번의 0번, 0번의 1번, 0번의 2번 식으로 0번 애니메이션에 대해서만 옵션을 정해 준 것

	15. spine_01에 blenddepth를 3을 준거랑 pelvis에는 4주고 thigh_l, thigh_r에 -1을 주는 것에 차이는
	- pelvis에 1/4만큼의 블렌딩될 애니메이션이 적용되는 것
	- -1은 해당 본 밑으로 적용 안 시켜줌
	- 0은 해당 본에만 적용

	16. HUD는 HeadUpDisplay의 약자로 플레이어의 전방에 정보를 표시해주는 역할을 하는데 예를 들어 유용한 쓰임새 중에
	- FPS 혹은 TPS에 에임을 표시해준다던가 하는게 있음
	- GameModeBase에서 내가 적용할 HUD 클래스를 세팅해줘야하고 블프 클래스를 만들 때 HUD 검색해서 클래스 만들 수 있고
	- Reviece Draw HUD Event를 받아서 넘어오는 인자 SizeX, SizeY로 화면 크기를 알아내서 어디 위치에 어떤 크기로 HUD를 표시할지 정할 수 있음
	- DrawMaterial에 ScreenX,Y가 Draw를 시작할 왼쪽은 x, 위쪽은 y 좌표를 받고 ScreenW, H를 통해 어떤 크기로 그릴지 정함

	17. 