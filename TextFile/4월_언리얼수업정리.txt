======
0403
======
	1. 스킬을 구현하기 위해서 무기에서 했던 것과 같이 character의 beginplay에서 spawnactorfromclasses로 생성하여 가지고 있음
	- 클래스를 담는 배열과 래퍼런스를 담는 배열 구분
	- CurrentSkill 단일 변수를 만들어서 현재 스킬에 대한 것도 관리

	2. 위 작업을 constructionscript가 아닌 beginplay에서 하는 차이점에 대한 질문이 있었는데
	- 일단 첫번째로 저 작업을 beginplay에서 한 이유는 spawnactorfromclasses가 constructionscript에서는 부를 수 없음
	- constructionscript의 주 용도는 이 클래스를 월드에 배치 한 순간 동작하는 것이고
	- 인스턴스별로 뭔가 변화가 생겼을 때도 constructionscript를 실행해주는데
	- 이걸 응용하게 되면 bool변수나 enum변수로 어떤 변수를 주는지에 따라 어떤 component를 가질지를 인스턴스를 월드에 배치한 이후
	정할 수 있음
	- 하지만 또 한계라 한다면 AddComponentByClass같은 함수 사용은 제한되어서 명시적으로 변수의 어떤 값엔 어떤 컴포넌트를 추가하겠다 같은 식의
	선언을 해야 함
	- beginplay나 constructionscript나 생성자나 시작할 때 처리하는 것은 같지만 3개는 미묘하게 다른 부분이 있으니 일단 인지하고 넘어감
	- 추가로 변수 값 변화에 따라서 추가되는 component를 확인해 볼 때 에디터 개인설정 - 콘텐츠 에디터 - 블루프린트 에디터 - 디테일 보기에서 컨스트럭션 스크립트
	숨김 에 대해서 체크를 풀어주고 사용해야 변화된 component확인 가능(default는 constructionscript 숨김)

	3. sequence에서 이미 연결했던 핀을 다른 곳으로 옮겨주는 거 ctrl 누르고 핀 클릭 후 드래그하여 가능(sequence만은 아니고 모든 연결 선에 대해)

	4. 역할별로 comment 박스 만들어줌

	5. skill A,B,C 액션매핑 만들고(z,x,c) 컨트롤러에서 character에 상속한 skillA,B,C인터페이스 콜해줌
	- chracter쪽에서 상속받은 인터페이스 구현만 하면 skillA,B,C에 관한 키 입력 시 호출됨

	6. 키 입력을 길게 누르다가 떼야 작동하는 이벤트에 대해서 2가지 방법 정도 생각해 볼 수 있는데
	- 인터페이스에서 pressed랑 released에 대해 2가지 함수를 만들어서 각각 동작시켜주는 것이랑
	- 인터페이스쪽 함수에서 하나만 만드는데 대신 input값으로 bool변수 하나 받아서 filpflop으로 처리해주는 방법(키 이벤트의 pressed랑 released는 둘다 flipflop
	으로 들어오는 흐름, 누르면 true, 떼면 false 이런 식으로)

	7. Delay와 RetriggableDelay의 차이가 있는데
	- Delay는 Delay중에 다른 Delay가 들어오면 무시하고 본인의 남은 시간을 끝내기만 하는데
	- RetriggableDelay는 Delay중에 다른 RetriggableDelay가 들어오면 다시 그 시점부터 Delay 시작함
	- 적의 피격 색이랑 타격 시 경직에 대해 Delay -> RetriggableDelay로 바꿈

	8. Sequence와 Gate를 활용하여 이단입력에 대해서만 작동하도록 만들 수도 있는데
	- 키 이벤트 - Sequence - Gate 순으로 배치하고
	- Sequence의 Then0는 일단 실행쪽으로 들어가고(Gate가 처음엔 막혀있음)
	- Then1이 Open의 흐름에 들어가서 문을 열어주고
	- Then2는 delay0.25초 뒤에 Gate 문을 다시 닫음

	- 핵심은 Then1과 Then2 사이에서 새로운 키 입력에 대해서 Gate가 열려있기 때문에 Gate를 통과할 수 있게 됨

	9. IsValid로 변수에 대해 null체크를 할 수 있었는데 (혹은 class에 대해 null체크가 가능한 함수도 있음 IsValidClass였나?)
	- 변수 getter에 우클릭해서 변수의 유효성 검사를 통해 IsValid와 같은 일을 할 수 있음

======
0405
======
	1. 스킬 장착부분을 구현하는 것이 과제였음
	- weaponA,B를 장착하는 것과 비슷한 로직
	- getter에 유효성 검사를 해서 CurrentSkill에 유효성 검사를 적용하면 스킬 장착 여부를 알 수 있었고
	- 장착하지 않았다면 장착해주면 되고
	- 장착한 상태라면 지금 누른 스킬과 장착한 스킬이 같은지 아닌지를 검사해서 추가적인 처리를 해줌

	2. 정씨 과제중에 getter의 유효성 검사하는 노드에 대해서 호출 시점인지 아니면 cache된 내용일지에 대해 논란이 있었는데
	- 결론은 호출 시점에서 getter를 다시 돌리는 식임(본질이 getter이기 때문, 실행핀이 있지만)

	3. 게임에서 안 보이게 하는 방법 중에
	- CurrentWeapon - SkeletalMesh - SetVisibility보다
	- CurrentWeapon - ActorHiddenInGame 핀이 더 낫다고 하는데
	- 그 이유는 액터가 가지고 있는 딱 어느 대상을 집어서 동작시키는 코드는 피하는 게 좋다고 함

	4. 스킬이 장착되어 있지 않을 때만 무기 장착이 가능해야 하기 때문에
	- WeaponA,B쪽에서 진입 근처에 CurrentWeapon이 유효하지 않을때만 들어갈 수 있게 바꿈
	- 아마 공격도 마찬가지(Action)

	5. IsArmed같이 무기 장착 중인지 확인하기 위해 만들어놓은 함수 혹은 인터페이스가 있다면 이것을 쓰는 것이 맞음
	- CurrentWeapon을 검증된 get으로 변환해서도 같은 작업이 동일하지만 이렇게 IsArmed를 써야 하는 이유는
	- 코드의 가독성도 그렇고 IsArmed가 변화했을 때 일괄 처리되어야 하기 때문임

	6. BS_Caster 블렌드 스페이스를 만들어줌
	- Wizard_Idle, WizardWalk 4방향, WizardRun 4방향 적용해줌(Speed, Direction)

	7. ABP_Character의 이벤트 그래프 중에 수정해 준 부분이 있는데
	- ABP_Character가 Armed 변수를 가지고 있었고 그 변수를 매 tick마다 업데이트를 해주는 방식이였는데
	- 그 방법이 IsArmed 인터페이스를 콜해서 얻어오는 식이였음
	- 그것이 아니라 캐릭터가 무기를 장착하는 과정에서 ABP_Character의 변수를 업데이트하는 ABP의 인터페이스를 콜해주는 것이 맞는 방식
	- 하지만 기존 ABP의 bArmed로 스테이트 머신을 제어하는 방법은 안 쓰기로 했기 때문에 기존 bArmed 부분은 다 지워줌

	8. bArmed를 지웠기 때문에 캐릭터가 무장상태인지 비무장상태인지 알 방법이 없어짐
	- WeaponType 열거형을 추가하고(일단 None과 Sword를 가짐)
	- ABP전용 인터페이스를 만들어서
	- WeaponType을 input으로 받는 인터페이스 함수 정의해줌, 추가로 skill의 activate를 제어하는 input이 bool인 인터페이스 함수도 하나더 정의함
	- 무기의 최상위인 BP_Weapon이 아니라 상속받은 BP_Sword쪽에서 WeaponType값 지정해주고(Sword) BP_Weapon에선 이 type을 블프읽기전용으로 처리(야메임)

	- WeaponA,B 쪽 로직 끝 부분에 가서 ABP의 WeaponType변수를 바꾸는 로직 추가
	- ABP의 WeaponType으로 블레드 포즈 하는 노드가 있음

	9. ABP쪽에서 기존 Idle과 Sword상태를 전환하는 스테이트 머신을 지우고 
	- BlendPose(E_WeaponType)노드를 추가하고 (ABP가 가지고 있는 WeaponType변수가 무엇인지에 따라 애니메이션 결정함)
	- BlendSpace3개(Unarmed, Sword, Wizard)3개를 놓고
	- 각각 입력 핀에 변수를 연결해줘야 하는데 더 좋은 방법은
	- 노드 클릭 후 디테일 탭에서 핀에서 바로 X,Y값에 어떤 변수쓸지 할당해 줄 수 있었음

	- BlendPose 기본 포즈에 Unarmed주고 E_WeaponType이 Sword이면 BS_Sword포즈로 바뀌게끔 하고
	- Wizard포즈는 Sword에서도 갈 수 있고 Unarmed에서도 갈 수 있는 포즈이기 떄문에 bool로 블렌드 포즈하는 노드를 새로 만들어서
	- bSkillActivated변수로 제어함

	- 결론적으로 ABP가 가지고 있는 E_WeaponType으로 어떤 포즈 취할 지 먼저 정하고
	- bSkillActivated 변수가 켜져 있으면 BS_Wizard를 우선하는 방식으로 처리하는 것

	- BlendPose(E_WeaponType)에서 새로운 E_WeaponTyep이 생겨서 새로운 무기에 Type을 다르게 주면 새로운 BlendSpace를 넘겨서 다를 포즈를 취할 수 있게 됨

=======
0405
=======
	1. 스킬의 장착과 동작 전환까지 처리가 되었음
	- 스킬을 든 상태에서 action을 하면 칼 휘두르는 모션이 나감(weapon을 들다가 스킬을 꺼낸 경우)

	2. BP_Teleport를 구현하기 위해 Teleport의 tick에서는 매 프레임 커서가 가 있는 방향의 위치 정보와 그 위치의 법선벡터를 받아와서
	처리하게 되는데
	- 커서의 위치와 법선벡터를 구하는 함수 GetDestinationData를 만들었고
	이 함수는 GetHitResultUnderCursorForObjects에서 필요한 정보만 뽑아 낸 함수
	- 원래 이 처리를 하기에 적합한 함수는 아니나 소개할 기회가 없을 것 같아서 소개했다고 함(롤, 스타의 이동 같은 거 처리가 더 적합한 함수)
	- 적합한 함수는 LineTracing
	- cursor가 worldstatic에 대해서만 hit할 수 있도록 함수 배열에 넣어줌

	3. Tick마다 GetDestinationData를 활용해 cursor위치에 hit된게 있으면 그 위치에 Decal을 찍어주도록 만듬(visibilityOn, setlocation(decal))
	- 법선벡터를 활용해 decal의 rotation을 바꿈(decal의 전방을 hit된 곳의 법선벡터로 만들어줌, MakeRotFromX)

	4. 스킬을 들게 되면 무기를 든것과 동일하게 OrientRotationToMovement 옵션 건들여줌

	5. getter를 아끼지 마라
	- 가독성이 더 나음

	6. 마우스 좌클릭으로 무기를 통한 공격이나 스킬 공격을 둘 다 처리하는데
	- 스킬 공격을 우선 처리하도록
	- 무기를 든 상태에서 스킬을 활성화하면 IsArmed이기도 하고 스킬도 있지만 스킬을 우선 발동하도록 처리함
	- ActionA쪽에서 스킬쪽과 무기쪽으로 분기가 나뉨

	7. BP_Skill쪽에 BeginAction, EndAction이라는 커스텀 이벤트 만들고
	- Action쪽에서 스킬 발동하면 불러주는 식으로

	8. 스킬 발동은 스킬 시전하는 모션이 나오기 전에 BeginAction이 콜 되고 스킬에 만들어놓은 노티파이에 대해 EndAction을 부르는 식으로 만듬

	9. BP_Skill쪽에서 GetMontageData 기본 형태만 만들고 BP_Teleport에서 Teleport하는 몽타주를 연결해주기만 하면 되는데
	- Wizard_Spell_Montage를 실행하게 만들어주고
	- 시퀀스에서 몽타주를 만들 떄 만들고나서 슬롯설정을 필수 spell은 fullbody

	10. Teleport의 BeginAction에서 처리하는 내용은 Destination이 유효한지에 대해 bool에 저장하고 실제 이동위치를 그 위치의 수직 150 위로 Destination변수에 설정

	11. EndAction에서는 Emitter를 발생시키고 실제 캐릭터의 SetActorLocation으로 설정해 줌

	12. 이미터는 도착지랑 출발지에 둘다 설치하기로 함
	
	13. 이미터 눈뽕이 오져서 이미터를 살짝 바꿔줬는데
	- 스케일을 .5로 줄이고 이미터 자체의 눈뽕 효과를 꺼줌
	- 아쉽게도 파티클(이미터)은 머티리얼 인스턴스처럼 상속해서 개별로 뻗어나가는 식의 처리는 불가능
	- 복사해서 이름 바꿔서 사용해야 하는 듯

=======

=======