======
0403
======
	1. 스킬을 구현하기 위해서 무기에서 했던 것과 같이 character의 beginplay에서 spawnactorfromclasses로 생성하여 가지고 있음
	- 클래스를 담는 배열과 래퍼런스를 담는 배열 구분
	- CurrentSkill 단일 변수를 만들어서 현재 스킬에 대한 것도 관리

	2. 위 작업을 constructionscript가 아닌 beginplay에서 하는 차이점에 대한 질문이 있었는데
	- 일단 첫번째로 저 작업을 beginplay에서 한 이유는 spawnactorfromclasses가 constructionscript에서는 부를 수 없음
	- constructionscript의 주 용도는 이 클래스를 월드에 배치 한 순간 동작하는 것이고
	- 인스턴스별로 뭔가 변화가 생겼을 때도 constructionscript를 실행해주는데
	- 이걸 응용하게 되면 bool변수나 enum변수로 어떤 변수를 주는지에 따라 어떤 component를 가질지를 인스턴스를 월드에 배치한 이후
	정할 수 있음
	- 하지만 또 한계라 한다면 AddComponentByClass같은 함수 사용은 제한되어서 명시적으로 변수의 어떤 값엔 어떤 컴포넌트를 추가하겠다 같은 식의
	선언을 해야 함
	- beginplay나 constructionscript나 생성자나 시작할 때 처리하는 것은 같지만 3개는 미묘하게 다른 부분이 있으니 일단 인지하고 넘어감
	- 추가로 변수 값 변화에 따라서 추가되는 component를 확인해 볼 때 에디터 개인설정 - 콘텐츠 에디터 - 블루프린트 에디터 - 디테일 보기에서 컨스트럭션 스크립트
	숨김 에 대해서 체크를 풀어주고 사용해야 변화된 component확인 가능(default는 constructionscript 숨김)

	3. sequence에서 이미 연결했던 핀을 다른 곳으로 옮겨주는 거 ctrl 누르고 핀 클릭 후 드래그하여 가능(sequence만은 아니고 모든 연결 선에 대해)

	4. 역할별로 comment 박스 만들어줌

	5. skill A,B,C 액션매핑 만들고(z,x,c) 컨트롤러에서 character에 상속한 skillA,B,C인터페이스 콜해줌
	- chracter쪽에서 상속받은 인터페이스 구현만 하면 skillA,B,C에 관한 키 입력 시 호출됨

	6. 키 입력을 길게 누르다가 떼야 작동하는 이벤트에 대해서 2가지 방법 정도 생각해 볼 수 있는데
	- 인터페이스에서 pressed랑 released에 대해 2가지 함수를 만들어서 각각 동작시켜주는 것이랑
	- 인터페이스쪽 함수에서 하나만 만드는데 대신 input값으로 bool변수 하나 받아서 filpflop으로 처리해주는 방법(키 이벤트의 pressed랑 released는 둘다 flipflop
	으로 들어오는 흐름, 누르면 true, 떼면 false 이런 식으로)

	7. Delay와 RetriggableDelay의 차이가 있는데
	- Delay는 Delay중에 다른 Delay가 들어오면 무시하고 본인의 남은 시간을 끝내기만 하는데
	- RetriggableDelay는 Delay중에 다른 RetriggableDelay가 들어오면 다시 그 시점부터 Delay 시작함
	- 적의 피격 색이랑 타격 시 경직에 대해 Delay -> RetriggableDelay로 바꿈

	8. Sequence와 Gate를 활용하여 이단입력에 대해서만 작동하도록 만들 수도 있는데
	- 키 이벤트 - Sequence - Gate 순으로 배치하고
	- Sequence의 Then0는 일단 실행쪽으로 들어가고(Gate가 처음엔 막혀있음)
	- Then1이 Open의 흐름에 들어가서 문을 열어주고
	- Then2는 delay0.25초 뒤에 Gate 문을 다시 닫음

	- 핵심은 Then1과 Then2 사이에서 새로운 키 입력에 대해서 Gate가 열려있기 때문에 Gate를 통과할 수 있게 됨

	9. IsValid로 변수에 대해 null체크를 할 수 있었는데 (혹은 class에 대해 null체크가 가능한 함수도 있음 IsValidClass였나?)
	- 변수 getter에 우클릭해서 변수의 유효성 검사를 통해 IsValid와 같은 일을 할 수 있음

======
0405
======
	1. 스킬 장착부분을 구현하는 것이 과제였음
	- weaponA,B를 장착하는 것과 비슷한 로직
	- getter에 유효성 검사를 해서 CurrentSkill에 유효성 검사를 적용하면 스킬 장착 여부를 알 수 있었고
	- 장착하지 않았다면 장착해주면 되고
	- 장착한 상태라면 지금 누른 스킬과 장착한 스킬이 같은지 아닌지를 검사해서 추가적인 처리를 해줌

	2. 정씨 과제중에 getter의 유효성 검사하는 노드에 대해서 호출 시점인지 아니면 cache된 내용일지에 대해 논란이 있었는데
	- 결론은 호출 시점에서 getter를 다시 돌리는 식임(본질이 getter이기 때문, 실행핀이 있지만)

	3. 게임에서 안 보이게 하는 방법 중에
	- CurrentWeapon - SkeletalMesh - SetVisibility보다
	- CurrentWeapon - ActorHiddenInGame 핀이 더 낫다고 하는데
	- 그 이유는 액터가 가지고 있는 딱 어느 대상을 집어서 동작시키는 코드는 피하는 게 좋다고 함

	4. 스킬이 장착되어 있지 않을 때만 무기 장착이 가능해야 하기 때문에
	- WeaponA,B쪽에서 진입 근처에 CurrentWeapon이 유효하지 않을때만 들어갈 수 있게 바꿈
	- 아마 공격도 마찬가지(Action)

	5. IsArmed같이 무기 장착 중인지 확인하기 위해 만들어놓은 함수 혹은 인터페이스가 있다면 이것을 쓰는 것이 맞음
	- CurrentWeapon을 검증된 get으로 변환해서도 같은 작업이 동일하지만 이렇게 IsArmed를 써야 하는 이유는
	- 코드의 가독성도 그렇고 IsArmed가 변화했을 때 일괄 처리되어야 하기 때문임

	6. BS_Caster 블렌드 스페이스를 만들어줌
	- Wizard_Idle, WizardWalk 4방향, WizardRun 4방향 적용해줌(Speed, Direction)

	7. ABP_Character의 이벤트 그래프 중에 수정해 준 부분이 있는데
	- ABP_Character가 Armed 변수를 가지고 있었고 그 변수를 매 tick마다 업데이트를 해주는 방식이였는데
	- 그 방법이 IsArmed 인터페이스를 콜해서 얻어오는 식이였음
	- 그것이 아니라 캐릭터가 무기를 장착하는 과정에서 ABP_Character의 변수를 업데이트하는 ABP의 인터페이스를 콜해주는 것이 맞는 방식
	- 하지만 기존 ABP의 bArmed로 스테이트 머신을 제어하는 방법은 안 쓰기로 했기 때문에 기존 bArmed 부분은 다 지워줌

	8. bArmed를 지웠기 때문에 캐릭터가 무장상태인지 비무장상태인지 알 방법이 없어짐
	- WeaponType 열거형을 추가하고(일단 None과 Sword를 가짐)
	- ABP전용 인터페이스를 만들어서
	- WeaponType을 input으로 받는 인터페이스 함수 정의해줌, 추가로 skill의 activate를 제어하는 input이 bool인 인터페이스 함수도 하나더 정의함
	- 무기의 최상위인 BP_Weapon이 아니라 상속받은 BP_Sword쪽에서 WeaponType값 지정해주고(Sword) BP_Weapon에선 이 type을 블프읽기전용으로 처리(야메임)

	- WeaponA,B 쪽 로직 끝 부분에 가서 ABP의 WeaponType변수를 바꾸는 로직 추가
	- ABP의 WeaponType으로 블레드 포즈 하는 노드가 있음

	9. ABP쪽에서 기존 Idle과 Sword상태를 전환하는 스테이트 머신을 지우고 
	- BlendPose(E_WeaponType)노드를 추가하고 (ABP가 가지고 있는 WeaponType변수가 무엇인지에 따라 애니메이션 결정함)
	- BlendSpace3개(Unarmed, Sword, Wizard)3개를 놓고
	- 각각 입력 핀에 변수를 연결해줘야 하는데 더 좋은 방법은
	- 노드 클릭 후 디테일 탭에서 핀에서 바로 X,Y값에 어떤 변수쓸지 할당해 줄 수 있었음

	- BlendPose 기본 포즈에 Unarmed주고 E_WeaponType이 Sword이면 BS_Sword포즈로 바뀌게끔 하고
	- Wizard포즈는 Sword에서도 갈 수 있고 Unarmed에서도 갈 수 있는 포즈이기 떄문에 bool로 블렌드 포즈하는 노드를 새로 만들어서
	- bSkillActivated변수로 제어함

	- 결론적으로 ABP가 가지고 있는 E_WeaponType으로 어떤 포즈 취할 지 먼저 정하고
	- bSkillActivated 변수가 켜져 있으면 BS_Wizard를 우선하는 방식으로 처리하는 것

	- BlendPose(E_WeaponType)에서 새로운 E_WeaponTyep이 생겨서 새로운 무기에 Type을 다르게 주면 새로운 BlendSpace를 넘겨서 다를 포즈를 취할 수 있게 됨

=======
0405
=======
	1. 스킬의 장착과 동작 전환까지 처리가 되었음
	- 스킬을 든 상태에서 action을 하면 칼 휘두르는 모션이 나감(weapon을 들다가 스킬을 꺼낸 경우)

	2. BP_Teleport를 구현하기 위해 Teleport의 tick에서는 매 프레임 커서가 가 있는 방향의 위치 정보와 그 위치의 법선벡터를 받아와서
	처리하게 되는데
	- 커서의 위치와 법선벡터를 구하는 함수 GetDestinationData를 만들었고
	이 함수는 GetHitResultUnderCursorForObjects에서 필요한 정보만 뽑아 낸 함수
	- 원래 이 처리를 하기에 적합한 함수는 아니나 소개할 기회가 없을 것 같아서 소개했다고 함(롤, 스타의 이동 같은 거 처리가 더 적합한 함수)
	- 적합한 함수는 LineTracing
	- cursor가 worldstatic에 대해서만 hit할 수 있도록 함수 배열에 넣어줌

	3. Tick마다 GetDestinationData를 활용해 cursor위치에 hit된게 있으면 그 위치에 Decal을 찍어주도록 만듬(visibilityOn, setlocation(decal))
	- 법선벡터를 활용해 decal의 rotation을 바꿈(decal의 전방을 hit된 곳의 법선벡터로 만들어줌, MakeRotFromX)

	4. 스킬을 들게 되면 무기를 든것과 동일하게 OrientRotationToMovement 옵션 건들여줌

	5. getter를 아끼지 마라
	- 가독성이 더 나음

	6. 마우스 좌클릭으로 무기를 통한 공격이나 스킬 공격을 둘 다 처리하는데
	- 스킬 공격을 우선 처리하도록
	- 무기를 든 상태에서 스킬을 활성화하면 IsArmed이기도 하고 스킬도 있지만 스킬을 우선 발동하도록 처리함
	- ActionA쪽에서 스킬쪽과 무기쪽으로 분기가 나뉨

	7. BP_Skill쪽에 BeginAction, EndAction이라는 커스텀 이벤트 만들고
	- Action쪽에서 스킬 발동하면 불러주는 식으로

	8. 스킬 발동은 스킬 시전하는 모션이 나오기 전에 BeginAction이 콜 되고 스킬에 만들어놓은 노티파이에 대해 EndAction을 부르는 식으로 만듬

	9. BP_Skill쪽에서 GetMontageData 기본 형태만 만들고 BP_Teleport에서 Teleport하는 몽타주를 연결해주기만 하면 되는데
	- Wizard_Spell_Montage를 실행하게 만들어주고
	- 시퀀스에서 몽타주를 만들 떄 만들고나서 슬롯설정을 필수 spell은 fullbody

	10. Teleport의 BeginAction에서 처리하는 내용은 Destination이 유효한지에 대해 bool에 저장하고 실제 이동위치를 그 위치의 수직 150 위로 Destination변수에 설정

	11. EndAction에서는 Emitter를 발생시키고 실제 캐릭터의 SetActorLocation으로 설정해 줌

	12. 이미터는 도착지랑 출발지에 둘다 설치하기로 함
	
	13. 이미터 눈뽕이 오져서 이미터를 살짝 바꿔줬는데
	- 스케일을 .5로 줄이고 이미터 자체의 눈뽕 효과를 꺼줌
	- 아쉽게도 파티클(이미터)은 머티리얼 인스턴스처럼 상속해서 개별로 뻗어나가는 식의 처리는 불가능
	- 복사해서 이름 바꿔서 사용해야 하는 듯

=======
0406
=======
	1. 텔레포트 만들고 나서 마지막 수정은 일정거리 이상일 때 데칼이 안 보이는 것인데 
	- Decal의 FadeScreenSize를 0으로 바꿔줌(default 0.01)
	- 화면의 몇 퍼센트 밑으로 크기가 작아지면 화면에서 안 보이게 하는 옵션(default 1%)

	2. 새로운 스킬 FireStrom을 만들어보자
	- BP_Skill 상속받고
	- ParticleSystem 추가하고
	- ParticleSystem의 AutoActivate끄고
	- collision 추가해주고 크기 맞춰주고(z위치300 캡슐크기 높이 : 500, 반지름 : 200)
	- 캡슐의 overlapevents 꺼주고

	3. 다단히트로 구현하기 위해
	- beginoverlap되면 배열에 넣고 endoverlap되면 배열에서 빼고
	- 배열에 들어있는 애들에 대해 0.몇초마다 데미지를 넣는 방식

	4. 주변을 도는 화염 기둥을 구현하기 위해 스킬 발동하면 캐릭터의 전방 vector를 기준 벡터로 잡고 각도를 0으로 초기화해줌(EndAction, 몽타주의 노티파이)
	- particle은 activate해주고 capsule의 overlap은 켜줌

	5. 오버라이드 가능한 이벤트들은 왼쪽탭에서 우클릭 후 함수로 변환 가능(local변수가 필요하다면? 써볼만한)

	6. tick에서는 particle이 active라면 불기둥이 돌아가는 처리를 해주어야 하는데 2가지 방법이 있음
	- 어려운 방법은 삼각함수의 cos, sin을 이옹해서 actor위치 기준으로 각을 계산해서 setactorlocation 해주는 것

	7. tick에서 각도에 대해 +1 씩 해주는 방법은 문제가 있음
	- 컴퓨터 사양에 따라 tick호출 횟수가 달라서 사양이 좋으면 스킬이 빠르고 안좋은면 느려짐
	- AngularSpeed * DeltaSeconds를 Angle에 tick마다 더해주면 사양에 상관없는 같은 결과를 얻을 수 있음

	8. 0.125초마다 배열의 담긴 액터들한테(불기둥안에 들어온) 데미지를 주기 위해 간단한 구현은
	- Tick에서 Delay로 처리하는게 간단한 방법(Retriggable은 여기서 쓰면 안됨)
	- Deligate를 써서 해결해보자

	9. SetTimerByEvent로 CustomEvent(DamageEvent만들어서 할당해주고 .125초마다 발동하게 끔 처리
	- CustomEvent(DamageEvent에 대해 처리해주는 것

	10. 5초 뒤에 스킬을 꺼주기 위해
	- SetTimerByEvent에서 Event핀에 EventDispatcher에서 생성해서 스킬을 끄는 함수를 물려줌(OnTimeOver)
	- 함수를 이벤트로서 timer에 바인딩해주는 느낌
	- OnTimeOver는 particle을 deactivate하고 capsule의 overlapevents를 꺼주는 함수

======
0407
======
	1. SetTimerByEvent의 실햄흐름은 다른 흐름이라고 봐야 함
	- 세팅된 시간만큼 바인딩 된 이벤트의 흐름을 실햄 함
	- 타이머 설정을 해주었으면 필요하지 않을 때 꺼야하는데
	- pause하는 방법이 있고 timer를 비웠다가 다시 세팅하는 식의 방법이 있음
	- 걸어준 이벤트에 함수를 거는 방법이 있는데 이벤트 생성 노드를 만들어서 함수를 걸어주었음
	- 근데 이벤트 디스패처가 함수를 커스텀 이벤트로 만드는 것이냐고 했을 땐 아닌 것이
	- 이벤트 디스패처의 본질은 함수 포인터인 것이고 단지 걸어준 함수를 이벤트로서 사용할 수 있던 것

	- pause, unpause는 unpause 당시 시간이 남아있기 때문에 부정확할 수 있음
	- 그런 오차가 허용 안되는 상황이면 타이머를 비우는 방식을 채택해야 함
	
	2. 위에서 사용했던 이벤트 생성은 싱글캐스트 델리게이트 인것 같음
	- 이유는 변수로 만들 수 있는 이벤트 디스패처는 기본값이 멀티캐스트 델리게이트이며 편집이 불가능한데
	- 이걸 만들어서 SetTimerByEvent에 걸어주고 싶었는데 실패했음
	- 그리고 이벤트 생성 노드도 핀추가라던가 더 걸어줄 함수를 추가하는 핀이 없었음

	- 이벤트 디스패처에 여러 이벤트를 걸었다면 그 디스패처를 호출해서 실행흐름이 있는 핀으로서 연겨해주면 되는데
	- 이게 SetTimer노드의 이벤트에 바인딩 되려면 디스패처를 커스텀이벤트로서 다시 만들어서 거기서 호출 노드를 흐름으로 연결해주면 됨

	- 이벤트 디스패처에는 input인자들이 같고 output은 없어야 함
	- 멀티캐스트에서는 기본적으로 반환값을 활용을 못하는데 블프에서는 반환값이 있으면 그 자체로도 멀티캐스트 델리게이트에 걸어줄 수 없었고
	- C++에서는 반환값이 있어도 걸어줄 순 있으나 반환값의 활용은 힘든 것으로 보임

	3. 멀티캐스트 델리게이트는 옵저버 패턴에 활용하기에 좋음
	- 업적 시스템같은
	- 기본적으로는 인터페이스가 더 강력하기 때문에 인터페이스를 적극 활용하는 것이 좋음(커플링 면에서도 인터페이스가 약한 커플링)

	4. EndOverlap에서 OverlappedActors배열을 비워주는 것과 별개로 스킬이 끝나는 시점에서도 비워줘야 함
	- 버그가 발생할 수 있음
	- 아마 겹쳐있는 시점에서 EndOverlap이 호출되지 않고 스킬이 꺼지면 그럴 수 있다는 것 같음

	5. overlappedactor가 배열인 이유는 결국 특정 원소를 꺼내야 처리할 수 있는 내용이 있기 때문
	- overlap이 끝나면 특정 액터를 배열에서 비워주는 식의 작업이 이에 해당
	- set이였다면 결국 배열로 바꿔서 처리해야 하기 때문에 2번 일하는 꼴

	6. 블프의 배열은 읽기 전용으로 걸어도 값이 변경 가능함
	- 이런 빈틈이 있는 이유는 ADD, REMOVE같은 함수가 Library에서 불러 쓰는 것이기 때문
	- Set같은 경우는 막을 수 있음(다른 배열을 통째로 덮어 쓰는 경우)

	7. RotateVectorAroundAxis가 있는데 우리 수업은 고정 값 정면 벡터에 대해 angle값만 변경시켜주어서 스킬의 location을 정해주는 방식
	- 아마 중요한 점은 angle이 변하는 값이고 벡터는 고정값이어야 함
	- 축은 z축을 기준으로 주었는데 getactorforwardvector라던가 다양한 vector를 넘겨주어서 다양한 표현이 가능

	8. 결국 파이어스톰이 캐릭터 주위를 돌수 있는 것은
	- 월드상의 원점을 기준으로 어떤 방향을 가질 지 벡터를 정해놓고 그 벡터에 얼마만큼 멀어질지 상수값을 곱해서
	- 내 캐릭터의 위치에 그 벡터를 틱마다 더해주어야 가능

	9. 새로운 스킬 파이어볼을 만들기 위해 스킬이 activate된 시점에 몸 주변에 불타는 오라를 켜줬는데 꺼질 때 반응이 늦어보임
	- 파티클 자체에 꺼질 때 딜레이를 얼마나 줄지에 대한 옵션이 있긴 한데 잘 적용이 안된다고 함
	- 바로 꺼지길 원한다면 visible을 건드리면 된다고 함
	- 이거 관련해서 파티클의 원본에 가서 특정 이미터에 적용된 lifetime에서 값을 수정해주면 되긴 함

	- 추가로 파티클 관련해서 따로 만져봤는데 캐스케이드(파티클 편집기) 내에 커브에디터에 특정 이미터에 소속된 특정 이미터를 올려주면 값 그래프로서 편집이 가능함
	- 이미터에 걸려있는 머티리얼에 대해 dynamic으로 바꾸고 값을 바꿔주는 식으로 해봤는데 이미터가 그 머티리얼에 색을 덧씌운다던가 하는 방식으로
	작동하기에 적용이 안 되었었음
	- 현재로선 파티클을 내 입맛대로 다루려면 케스케이드에서 내가 직접 편집하는 수밖에 없는 듯
	- 개인적으로는 파티클의 전체 visibility를 꺼버리기 보단 파티클을 직접 편집하는 게 연출 상 더 좋아보이는데
	- 큰 덩어리는 빠르게 꺼주고 잔상은 남기는 식으로 편집하면 좋을 듯

	10. ABP에서 본마다 레이어로 블렌딩 노드에서 MeshSpaceRotationBlending 옵션이 있었는데 이걸 체크해주어야 Wizard_Attack 몽타주가 제대로 동작
	- 로컬 스페이스는 spine_01을 기준으로 하체에 대해서 원래 애니메이션이 회전이 없기 때문에 회전을 안 시킨 듯
	- 하지만 wizard_idle포즈와 wizard_attack포즈가 각각 개별로 동작했을 때 이걸 블렌딩 하면 실제로는 attack시 하체는 그대로고 상체가 돌아야 함
	- 메시 스페이스에서의 회전을 적용시켜줘서 하체와 상체가 기존의 애니메이션과는 다르게 돌릴 수 있었음

	11. 캐릭터에 적용된 스켈레탈 메시는 -90도 돌리고 z위치를 -90 내려서 적용해주었는데
	- 이렇게 되면 기존의 스켈레탈 메시랑 비교해서 정면 축이 바뀐 것이고 이것이 본마다 레이어로 블렌딩 노드에서 문제가 생기게 된 이유임
	
	12. 로컬 스페이스에서 블렌딩을 하게 되면 그 공간에서 attack 애니메이션은 하체에 연결 되어서 하체의 rotation에 영향을 받은 애니메이션인거고
	메시 스페이스는 하체에 영향을 받았더라도 최종적으로 하체가 영향을 준 상체를 블렌딩하겠다는 뜻

	13. 이렇게까지 하고 나면 상체가 너무 도는 문제가 있었는데 상체 부분에 블렌딩 된 애니메이션에 대해 뼈마다 얼마나 적용할지 정해주는 BlendDepth옵션이 있었음
	- 설정한 뼈를 기준으로 BlendDepth가 4라면 설정한 뼈는 1/4의 블렌드를 그 뼈 바로 위의 자식은 1/3, 그 위는 1/2, 1/1, 1/1, 1/1...되는 옵션임
	- 그래서 Depth가 높아지면 설정한 뼈 근처에서는 블렌딩 된 애니메이션이 적게 나오기 때문에 허리가 덜 돌아가 보이는 것

	14. 지금 설정한 뼈가 0번의 0번 인덱스인데 0번의 1번 0번의 2번 이런 식으로 블렌딩하기 위해 들어오는 애니메이션에 옵션을 더 달아 줄 수 있고
	- 만약에 노드 자체에 핀을 추가해서 1번 애니메이션 2번 애니메이션을 추가로 블렌딩 할떄는 1번의 0번, 1번의 1번, 2번의 0번, 2번의 1번 이런 식으로
	몇 번째 애니메이션의 뼈에 얼마만큼의 뎁스를 줄지를 각각 정해 줄 수 있음
	- 우리가 한 건 0번의 0번, 0번의 1번, 0번의 2번 식으로 0번 애니메이션에 대해서만 옵션을 정해 준 것

	15. spine_01에 blenddepth를 3을 준거랑 pelvis에는 4주고 thigh_l, thigh_r에 -1을 주는 것에 차이는
	- pelvis에 1/4만큼의 블렌딩될 애니메이션이 적용되는 것
	- -1은 해당 본 밑으로 적용 안 시켜줌
	- 0은 해당 본에만 적용

	16. HUD는 HeadUpDisplay의 약자로 플레이어의 전방에 정보를 표시해주는 역할을 하는데 예를 들어 유용한 쓰임새 중에
	- FPS 혹은 TPS에 에임을 표시해준다던가 하는게 있음
	- GameModeBase에서 내가 적용할 HUD 클래스를 세팅해줘야하고 블프 클래스를 만들 때 HUD 검색해서 클래스 만들 수 있고
	- Reviece Draw HUD Event를 받아서 넘어오는 인자 SizeX, SizeY로 화면 크기를 알아내서 어디 위치에 어떤 크기로 HUD를 표시할지 정할 수 있음
	- DrawMaterial에 ScreenX,Y가 Draw를 시작할 왼쪽은 x, 위쪽은 y 좌표를 받고 ScreenW, H를 통해 어떤 크기로 그릴지 정함

	17. 액터는 렌더링을 할 최소거리와 최대거리를 설정할 수 있음
	- 최소거리는 설정한 거리보다 가까우면 렌더링을 하지 않음
	- 최대거리는 설정한 거리보다 멀면 렌더링을 하지 않음

	- 최대거리를 활용해서 멀리 있는 것은 안 보이게 할 수 있을 듯

	18. cull distance volume을 사용해서 크기와 거리를 세팅해서 컬링을 할지 말지 정할 수 있음
	- 문서에서 추천하는 기본 세팅은 
	- <크기, 배열> 짝으로 <0, 1000>, <128, 2048>, <256, 4096>, <512, 8192>, <1024, 16384>, <2048, 0>

========
0411
========
	1. Wizard_Attack이 메시스페이스에서 로테이트 블렌딩하는 옵션을 켜지않았을 때 문제가 생긴 이유는
	- 애니메이션 자체가 루트 본이 회전하는 형태이기 때문
	- 루트본이 회전하는 이유가 있는데 Wizard_Attack의 애니메이션 출처가 mixamo라는 사이트에서 가져온 건데
	- 루트본이 없는 상태인데 언리얼로 임포트하는 과정에서 루트본이 pelvis의 회전을 따라가기 때문임
	- 앵간하면 본마다 레이어로 블렌딩 노드에서는 메시스페이스에서 회전 블렌딩 옵션을 켜는 게 좋다고 함

	2. fireball을 구현하기 위해 GetDestinationData 함수를 하나 만드는데
	- 카메라의 위치에서 카메라가 바라보는 방향으로 10000만큼의 거리를 라인 트레이스 하는건데
	- 이때 카메라를 가져오는 방법이 신기했음
	- playercontroller에서 cameramanager를 가지고 와서 location과 rotation을 가져옴
	- player가 카메라를 들고 있기 때문에 player에 형변환을 해서 camera를 직접 가져오는 방법도 있지만 유연하지 않음
	
	3. camera의 위치와 camera의 정면벡터로부터 10000 떨어진 지점을 목표지점으로 잡고 LineTrace를 하는데
	- 어떤 종류의 대상을 감지할지를 정하고(TypeObject, Pawn(우리는 몬스터한테 데미지 줄거니까)), TypeObject는 콜리전 관련 옵션에 있는 것
	- 어떤 종류의 대상을 무시할지를 정하고(Instigator)
	- 디버그 할 때 어떤 경로로 LineTrace찍었는지도 보여줌, hit한 대상에 대해선 네모박스로 보여줌(duration으로 시간지나면 사라지게 가능, persistant도 있음)
	Duration은 밑에 옵션 DrawTime에 영향 받음

	4. 우리가 던질 파이어 볼은 발동 시 무조건 나가야 하기 때문에
	- LineTrace결과가 성공이라면 Hit한 결과를 return하고
	- 실패라면 TraceEnd 지점을 겨냥해서 쏨

	5. 파이어볼 같은 투사체를 위한 component가 있음 -> projectile movement
	- 투사체가 파이어볼인지 화살인지에 따라 어떤 속성을 부모에서 물려주어야 할지 모호한데
	- 콜리전도 어떤 모양을 가져야 할지가 모호함
	- 투사체 최상위 부모에선 projectile movement 만을 가지고 있고
	- damage 변수를 하나 만들긴 했지만
	- 오버워치의 아나의 투사체는 힐을 주기에 damage가 최상위 부모에 오기엔 부적합함
	- fm으로 처리를 하려면 damage를 주는 투사체와 다른 역할을 하는 투사체로 한 번 더 분기를 나눴어야 함
	- Check라는 함수를 만들고 instigator도 아니고 owner도 아닌지 판별하는 퓨어함수를 하나 만듬
	- beginoverlap에서 applydamage처리를 하는 이벤트를 추가함(BP_Projectile, 최상위)

	6. BP_ProjectileFireball로 자손을 만들고 
	- particle과 collision(sphere)을 추가하고 particle 세팅해주고 정면 설정해 줌
	- 지금 상태로는 놓으면 중력에 영향을 받음
	- projectile movement에서 옵션 설정을 좀 해주어야 하는데 projectile - projectile gravity scale을 0으로 (1이 기본 중력)
	- projectile - Rotation follows Veclocity도 켜주고 (날아가는 방향으로 전방을 바꿈)
	- 위에를 키게 되면 Rotation remains Vectical을 켜고 끌 수 있는데 yaw에 대해서만 회전할 수 있게 바꾸는 것(좌우), 우리는 꺼줌
	- bounce에 대한 옵션도 있고 (마찰 등)
	- Homing도 있음(유도탄)

	- projectile 옵션 중에 initial velocity in localscale이 있는데 이걸 켜야 로컬 축 방향으로 속도 영향 받음
	- 밑에 velocity 옵션에서 설정하는 것
	- 만약 끄게 된다면 world의 x축 방향으로 날아감

	7. 액터마다 start with tick enabled 옵션은 다 꺼주는 것이 좋음
	- tick을 얼마마다 할지도 지정할 수 있음
	- fireball이 데미지를 입을리 없으니 canbedamaged같은 옵션도 여력이 된다면 꺼주는 게 좋음

	8. fireball의 beginoverlap 로직은
	- 일단 부모에서 만든 check함수가 true일때 (자기는 안 맞추고)
	- 맞은 위치에서 emitter를 스폰해주고(spawn emitter at location) apply radial damage함수로 광역딜 넣어주고 본체에 대한 딜도 넣어줌

	9. 카메라 위치를 시작위치로 정할 수 있음(fireball 테스트 중)

	10. BP_Fireball의 EndAction에서 fireball을 스폰해주면 됨(스폰 위치, 방향, 속력 처리 해줘야 함)
	- EndAction은 애니메이션 중에 던지려는 자세에 노티파이를 만들어 놨음

=======
0412
=======
	1. ApplyRadialDamage는 근원지로부터 멀어질수록 데미지가 덜 들어가는게 기본값
	- 균등하게 주려면 bool값 체크해줘야 함

	2. fireball을 어느 위치에서 어떤 방향으로 던져야 하는지가 문제인데
	- 손에서 던져야 하고
	- 정해놓은 끝 지점으로 던져야 함

	- 손에서 던지는건 GetInstigator - GetComponentByClass를 하여 SkeletalMeshComponent에서 정보를 훔쳐옴
	- SkeletalMesh로부터 Socket위치를 받아오는 GetSocketLocation으로 hand_r의 위치를 받아옴

	3. 2번 방법은 굉장히 위험한 방법임(강사님이 GetComponentByClass를 소개하기 위해 사용한 방법인 듯
	- 위 방법을 정말 사용해야 한다면 적어도
	- GetInstigator - CastToCharacter - GetComponentByClass - IsValid - GetSocketLocation 순으로 가거나
	- Interface로 Character가 상속받아서 GetSkeletalMeshSocketLocation 같은 이름으로 건내주는 방법이 그나마 안전할 듯

	- FireBall에서 받아온 SkeletalMesh에 SetSkeletalMesh 같은 함수로 캐릭터의 메시를 바꿔버리면 디버깅할 때 추적이 정말 어려워짐

	4. GetComponentByClass는 그 class가 가지고 있는 특정 component를 처음 만났을 때 그놈 딱 하나를 들고 오고 (계층 구조상 상위 컴포넌트가 걸릴 확률 높음)
	- GetComponentsByClass는 그 class가 가지고 있는 특정 component를 전부다 가지고와 배열로 리턴해줌

	5. FindLookAtRotation으로 시작지점을 손으로 주고 끝 지점을 Destination을 주어서 Projectile_FireBall의 Rotation으로 넘겨줌
	- 던질 fireball의 rotation을 정해준 것

	6. 던진 fireball이 overlap이 안되면 소멸이 안되는데
	- 시간이 지나면 액터를 사라지게 하기 위해 lifespan을 설정해주어야 하는데
	- actor의 기본 값에 있음

	7. 시간이 다 되서 사라질 때 폭발해서 스플뎀 입히도록
	- 기존 로직에서 액터와 맞았을 때 데미지를 주는 방식은 beginoverlap에서 처리하고
	- DestroyedActor이벤트에선 스플뎀을 처리해 줌(이 이벤트는 소멸 직전에 수행하는 것, 아직 Actor가 None이 아님)
	
	8. 충돌에 따라서 어디 맞았는지를 처리하는 게 질문이 들어왔는데
	- component의 overlap에서 어떤 component랑 부딪혔는지에서 GetObjectType을 가져와서 스위치로 처리할 수 있음
	
	- overlap(component버전) 이거 실험 좀 해봤는데 overlappedcomponent로 나오는 핀은 자기 자신이고
	- othercomponent로 나오는 핀은 overlap된 상대인데
	- 이 때 캐릭터는 mesh에도 collision이 있고 capsule에도 collision이 있어서 뭐가 나오나 실험을 해봤는데
	- overlapevent가 둘 다 켜져있다고 가정했을 때 mesh가 충돌되었고
	- 원래 세팅은 mesh의 overlap 이벤트는 꺼져있었기 때문에 capsule과 collision이 일어났음

	- enemy에서 capsule이랑 mesh에서 둘다 overlap만들어서 해봤는데 랜덤하게 맞음

	9. fireball을 든 상태에서 우클릭을 누르면 zoomin 떼면 zoomout을 만들기 위해
	- BP_skill에 빈 커스텀 이벤트 BeginActionB, EndActionB를 만들고
	- BP_Fireball에서 구현을 할 때 GetInstigator에서 Zoonin, Zoomout을 각각 오버라이딩 한 BeginActionB, EndActionB에 연결
	- 실제 ZoomIn과 ZoomOut은 player에서 구현

	- 결국 zoomin, zoomout을 하기 위해 값을 건드려야 하는 부분은 player가 가지고 있는 camera, springarm이기 때문에 그 값을 건드는 함수(인터페이스)는
	player에서 처리하고
	- 그 함수를 fireball의 특수 행동에서 콜을 해서 동작하게 하고
	- 실제 액션 바인딩의 내용 추가에선 current_skill의 특수행동을 콜하는 방식

	- 구조가 굉장히 기괴하나 유연함
	- 다른 스킬들의 다른 특수행동에 대해 짤 때 유연해짐

	10. Zoomin을 구현하기 위해 건드려야 할 값들은 camera::FieldOfView, springarm::targetarmlength, springarm::socketoffset

	11. 축 입력과 액션 입력에 대해 차이를 알아보면
	- 축 입력은 매 프레임 실행되는 tick 같은 함수
	- 단지 입력이 들어왔을 때 어떤 값을 뱉어내는지를 정해서 그 값으로 처리함

	- 액션 매핑은 입력이 들어온 그 한 순간 실행핀 처리함

	12. ZoomIn, ZoomOut에서 TimeLine을 이용한 처리를 하는데
	- float, vector, color, event에 대해 처리할 수 있고
	- event를 제외한 3개는 float이 몇개인지만 다름
	- 몇 초에 어떤 값을 가지고 또 몇 초에는 어떤 값을 가질지를 선형적으로 증가할 수 있는데
	그 값을 플레이어의 특정 값에 set해주면 시간에 따른 값의 증가 혹은 감소를 볼 수 있음
	- 시작에선 play로 핀이 들어가고 원래 상태로 돌아가기 위해 reverse핀에 넣어주는데

	- 이때 timeline내부에서 길이를 내가 원하는 값으로 설정해주어야 함
	안 했다면 reverse시 반응이 늦는 결과가 나옴(maxwalkspeed바꿔보다가 알게됨)

=======
0413
=======
	1. FireBall 스킬이 우클릭 시 줌하는 ActionB를 갖기 위해 BP_Player쪽에서 ZoomIn, ZoomOut을 적절한 시야로 구현하는게 과제였는데 
	- 핵심 키워드는 TimeLine, Camera::FieldOfView, SpringArm::TargetArmLength, SpringArm::SocketOffSet
	- 과제를 하면서 SpringArm::SocketOffset이 아닌 SpringArm::TargetOffset을 건드렸었는데 TargetOffset은 월드 좌표 기준으로 얼마나 떨어져있을지를 정하는 값임
	- 아마 TargetOffset의 z를 기본 75~100정도로 설정해줬던 이유가 수영할 때 플레이어의 축이 바뀌어도 카메라는 위에서 쳐다보는 시점으로 만들려고 했던 것 같음

	- 일단 과제에서 쓴 값들을 적으면 0~0.25초 동안
	FieldOfView : 80 -> 70
	TargetArmLenth : 300 -> 250
	SocketOffset.y : 0 -> 100
	SocketOffset.z : 0 -> -30

	- SocketOffset.z를 -30하는 이유가 의아할 수 있는데 TargetOffset.z가 100인 상황이였기 때문에 이렇게 했을 때 시야가 더 자연스러웠음

	2. 이벤트 그래프에 생성한 TimeLine은 변수 탭에 컴포넌트로서 존재하는데 component라는 것이 결국 주소를 알고 있는 포인터 변수이기 때문에 주소만 바꿔주면 다른 걸로도 set이 가능하다고 함
	- C++에서는 변수 탭이 아닌 컴포넌트 탭에 Timeline을 달고 있을 수 있는데 블프에서는 불가능했음(이유는 잘 모름)
	- ConstructionScript에서 AddComponentByClass를 해서 월드에 배치해서 인스턴스 생성 후 컴포넌트 탭에 있는 걸 보여주시려 한거 같은데
	ConstructionScript에서 AddComponentByClass는 불가능함
	- 이벤트 그래프에서 AddComponentByClass를 하면 TimelineComponent로서 존재하는 것을 확인할 수 있긴 함

	- 결론은 Timeline이라는 것은 component가 맞고 블프에서는 단지 변수로서 존재한다는 것

	3. Timeline에서 그래프의 형태는 linear뿐만 아니라 다양한 형태로 만들 수 있음
	- key 만들어 놓은 점에서 우클릭 후 설정 가능
	- TimeLine의 키를 편집할 때 vector같은 그래프는 x,y,z따로 볼 수도 있고 값을 잠궈놓고 편집할 수도 있음, 그래프에 눈이랑 자물쇠 모양 있음

	4. zoom이 가능하냐 불가능하냐라는 변수를 갖고 있어야 한다는 의견이 있었는데 이것이 아닌 이유는
	- BP_FireBall이라는 스킬이 두 번째 기능인 ActionB가 단지 ZoomIn, ZoomOut이였을 뿐
	- 설계 의도는 우클릭을 누르면 CurrentSkill의 ActionB가 실행되는 것인데 구현한 스킬마다 ActionB가 다른 스킬을 취하길 원한 것이고
	- 단지 FireBall의 ActionB가 ZoomIn, ZoomOut이였던 것
	- ActionB를 오버라이딩 하지 않는 BP_Skill의 자손 클래스들은 우클릭을 누르면 빈 ActionB를 실행하려다가 아무일도 일어나지 않는 형태로 구현된 것

	- FireBall이 ZoomIn, ZoomOut을 구현하기 위해선 player가 가지는 속성을 훔쳐와서 값을 바꾸는 작업을 해야하는 건데(여기선 camera, springarm 등)
	GetOwner - CastToBP_Player - Camera 이런 식으로 값을 가져와서 직접 수정할 수 있긴 하겠지만 이런 코딩이 많아지면 나중에 디버깅이 힘들어진다고 함
	- 그렇기 때문에 player에서 자신의 camera, springarm의 값을 바꾸는 ZoomIn, ZoomOut을 하는 함수를 구현해서 fireball쪽에선 player의 그 함수를 호출해야 하는 건데
	ZoonIn, ZoomOut이 인터페이스가 아니였다면 GetOwner - CastToBP_Player - ZoomIn을 하는 형태였을 거고 확장성이 낮아지는 요인으로 작용할 수 있음

	- 아무튼 ActionB의 발동 매커니즘은 Controller에서 우클릭을 하면 Player가 상속한 인터페이스인 ActionB를 호출하고 플레이어의 ActionB는 CurrnetSkill의 BeginActionB, EndActionB를 호출하고
	CurrentSkill에서 BP_Skill을 상속한 자손 스킬들이 오버라이딩한 BeginActionB, EndActionB가 실제로 실행되는 것임 단지 fireball이 구현하려는 내용이 player의 값을 건드리는 내용이여서
	player에서 이 내용을 바꿔주는 함수를 만들어서 넘겨준 것 뿐임

	5. 4번같은 로직이 아니라 A스킬이 B스킬을 알고 있으며 A스킬의 ActionB에서 B스킬의 ActionB를 호출하는 방식으로도 구현할 수 있는데 이런 구현은 B스킬을 가져다 쓴 곳에서 B스킬이 바꼈을 때
	직접적으로 영향을 받음
	- 게임 컨셉에 따라 이런 방법도 적용해봄직 함

	6. ZoomIn이 된 시점에 CameraLag이 있으면 움직임이 보기 불편한데 Zoom이 된 시점엔 SpringArm::EnableCameraLag을 껐다 켰다 하는 방식은 뚝뚝 끊겨보여서 더 부자연스러웠음
	- 위 내용 구현할 때 timeline에서 Finished, Direction, Switch 활용해서 구현함 -> play랑 reverse의 끝난 시점을 direction의 switch로 각각 처리하는 방식
	- CameraLagSpeed를 timeline에 추가해서 그 값을 뽑아다가 다시 set해주는 것이 보기에 더 자연스러울 것

	7. TimeLine내부에 외부커브를 들여올 수 있는데
	- 커브 클래스를 콘텐츠 브라우저에서 만들 수 있음, 편집 방식은 크게 다르지 않음
	- 외부커브를 적용하는 경우는 같은 커브를 여러군데에서 써야할 경우 고려해 볼만함, 아닌 경우 TimeLine에서 직접 편집하는 것이 더 편할 듯

	8. 에셋을 다중적용해야 할 경우가 있는데(보통은 머티리얼, 이번 경우는 외부커브) 콘텐츠 브라우저에서 ctrl 혹은 shift로 다중 선택해서 에셋 선택 창의 돋보기 모양 클릭하면 다중 적용 가능

	9. 외부커브의 응용이 가능한데
	- t : 0 -> 1, value : 0 -> 1 선형 증가하는 그래프 혹은 t : 0 -> 1, value : 1 ->0 선형 감소하는 그래프 등 자주 쓸 법한 외부커브는 만들어두고
	- timeline에서 만들어 둔 외부커브를 적용 후 나오는 값에 더하거나 곱하거나 해서 내가 원하는 값으로 사용 가능(더하거나 곱하는 것 보단 Lerp가 더 편함, LinerInterpolation 선형보간)
	- timeline에서 나오는 값을 Lerp의 alpha로서 사용
	
	10. Lerp의 상위호환 급으로 MapRangeClamped 라는 노드도 있었는데
	- Value : 20
	- InRangeA : 10
	- InRangeB : 30
	- OutRangeA : 100
	- OutRangeB : 2000일 때 

	- return되는 값은 1050인 식의 방식
	- 20이 10과 30의 중간 값이니깐 100과 2000의 중간 값인 1050이 return되는 것

	11. TimeLine에서 더 써봄직한 노드들이 있는데
	- SetPlayRate : TimeLine의 시간 축을 늘이거나 줄일 수 있음
	- SetTimeLineLength : TimeLine의 어느 시간까지 적용시킬 지

	12. 이벤트 그래프에 우클릭 후 어떤 관련 내용들만 볼 지를 정하는 게 <컨텍스트에 따라>를 toggle하는 방식으로 정할 수 있는데 
	- 추가적으로 <컨텍스트에 따라> 오른쪽에 화살표 클릭해서 어떤 내용 켤지 끌지 정할 수도 있음

	13. 추가적으로 줌을 했을 때 crosshair를 만들어 주기 위해 <콘텐츠 브라우저 우클릭 - 유저 인터페이스 - 위젯 블루 프린트>으로 WBP_CrossHair 만들고
	- 엔진 컨텐츠에서 대충 쓸만한 texture찾아서 우리 프로젝트로 <복사>해줌
	- <이동>하면 내 엔진은 그 texture 다른 프로젝트에서 사용 불가

	14. WBP_CrossHair에서 CanvasPannel 밑에 Image 달아주고 내용을 편집해주어야 하는데
	- 우측 상단에 FillScreen, Desired 등 화면을 어떻게 볼지 정하는 탭이 있는데
	FillScreen : CanvasPannel로서 적용된 점선 내(내 모니터의 해상도 혹은 default 값)에서 Image가 어떤 크기일 지 상대적으로 보여줬고
	Desired : Image가 실제로 100 * 30의 픽셀을 차지하는데 내 모니터상의 100 * 30만큼 차지한 것을 보여준 것 같음

	- Appreance - Image에서 사용할 이미지 파일 적용할 수 있고, ImageSize X, Y를 설정 가능
	- ImageSizeX,Y를 적용해도 모양이 이상한데 CanvasPanelSlot의 SizeToContent를 True로 줘야 제대로 적용되는데
	- CanvasPanel의 SizeX,Y가 또 따로 있는데 이게 아마 canvas에 추가한 Image로서 쓰기로 정한 도구의 크기가 100, 30이라는 뜻이고
	100, 30의 공간에서 내가 적용한 Image는 32 ,32 였는데 32, 32로 적용한 image가 100, 30의 공간에 맞춰 늘어났던 것으로 보임, SizeToContent를 true로 줌으로서
	내가 적용한 image파일의 크기 32, 32로 적용된 것 같음(100, 30이라는 값을 오버라이딩 적용한 듯)

	15. 에임을 화면의 정중앙을 주기 위해 1920 / 2, 1080 /2 한 값을 각각 X위치, Y위치에 주었는데 이것이 정확한 위치가 아닌 이유는
	- 앵커가 좌측상단을 기준으로 되어 있었기 때문이고
	- 좌측 상단부터 출력되는 이미지를 화면의 x절반, y절반만큼씩 이동시킨 것이고
	- Alignment가 0, 0이였는데 내 image의 좌측상단을 앵커에 맞춘다는 뜻이고 1,1은 우측 하단을 앵커에 맞춘다는 뜻임
	- 앵커를 좌측상단에 주고 1920 / 2, 1080 / 2, Alignment는 0.5, 0.5로 원하는 세팅을 할 수 있었지만

	- 조금 더 추가해서 앵커를 좌측 상단이 아닌 중앙으로 주고 X위치, Y위치를 0, 0 으로 줘도 같은 세팅을 줄 수 있었음
	
	16. 수업 끝나기 직전에 review로 먼저 보여주셨는데
	- 우리가 볼 수 없는 이유는 아직 WBP가 있긴 하지만 이 WBP를 적용해주겠다 라는 코드가 없기 때문임